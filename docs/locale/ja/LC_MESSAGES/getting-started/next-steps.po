#
msgid ""
msgstr ""
"Project-Id-Version: Celery 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-10 16:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../getting-started/next-steps.rst:5
msgid "Next Steps"
msgstr "ネクストステップ"

#: ../../getting-started/next-steps.rst:7
msgid ""
"The :ref:`first-steps` guide is intentionally minimal.  In this guide I will"
" demonstrate what Celery offers in more detail, including how to add Celery "
"support for your application and library."
msgstr ""
":ref:`first-steps` ガイドでは簡潔な説明に留めていましたが、"
"このガイドでは Celery をアプリケーションやライブラリに組み込む方法を含め、"
"Celery の機能をもう少し詳細にお見せしていきます。"

#: ../../getting-started/next-steps.rst:11
msgid ""
"This document does not document all of Celery's features and best practices,"
" so it's recommended that you also read the :ref:`User Guide <guide>`"
msgstr ""
"このドキュメントは Celery のすべての機能とベストプラクティスをまとめたものではないので、"
":ref:`User Guide <guide>` も併せて読むことをお薦めします。"

#: ../../getting-started/next-steps.rst:20
msgid "Using Celery in your Application"
msgstr "アプリケーションで Celery を使う"

#: ../../getting-started/next-steps.rst:25
msgid "Our Project"
msgstr ""

#: ../../getting-started/next-steps.rst:27
msgid "Project layout::"
msgstr "プロジェクト構成::"

#: ../../getting-started/next-steps.rst:34
msgid ":file:`proj/celery.py`"
msgstr ""

#: ../../getting-started/next-steps.rst:39
msgid ""
"In this module you created our :class:`@Celery` instance (sometimes referred"
" to as the *app*).  To use Celery within your project you simply import this"
" instance."
msgstr ""
"このモジュール内で :class:`@Celery` インスタンス(*app* と呼ばれることもあります)"
"を生成します。プロジェクト内で Celery を使う時は、このインスタンスをインポートします。"

#: ../../getting-started/next-steps.rst:43
msgid "The ``broker`` argument specifies the URL of the broker to use."
msgstr "``broker`` 引数では使用するブローカーの URL を指定します。"

#: ../../getting-started/next-steps.rst:45
msgid "See :ref:`celerytut-broker` for more information."
msgstr "詳細は :ref:`celerytut-broker` を参照してください。"

#: ../../getting-started/next-steps.rst:47
msgid "The ``backend`` argument specifies the result backend to use,"
msgstr "``backend`` 引数では使用する結果バックエンドを指定します。"

#: ../../getting-started/next-steps.rst:49
msgid ""
"It's used to keep track of task state and results. While results are "
"disabled by default I use the amqp result backend here because I demonstrate"
" how retrieving results work later, you may want to use a different backend "
"for your application. They all have different strengths and weaknesses.  If "
"you don't need results it's better to disable them.  Results can also be "
"disabled for individual tasks by setting the ``@task(ignore_result=True)`` "
"option."
msgstr ""
"結果バックエンドはタスクの状態と結果を追跡するのに使用されます。デフォルトでは無効になっているので、"
"ここでは amqp 結果バックエンドを使用し、後ほど結果の取得方法を説明します。"
"別のバックエンドを使うこともできます。バックエンドにはそれぞれの長所、短所があります。"
"結果が必要ない場合は、無効にしておいた方がベターです。"
"``@task(ignore_result=True)`` オプションをセットして個別のタスクに対して"
"無効化することも可能です。"

#: ../../getting-started/next-steps.rst:57
msgid "See :ref:`celerytut-keeping-results` for more information."
msgstr "詳細は :ref:`celerytut-keeping-results` を参照してください。"

#: ../../getting-started/next-steps.rst:59
msgid ""
"The ``include`` argument is a list of modules to import when the worker "
"starts.  You need to add our tasks module here so that the worker is able to"
" find our tasks."
msgstr ""
"``include`` 引数はワーカーが起動した際にインポートするモジュールのリストです。"
"ワーカーがタスクを見つけられるように、作成したタスクのモジュールをここに追加しておく必要があります。"

#: ../../getting-started/next-steps.rst:64
msgid ":file:`proj/tasks.py`"
msgstr ""

#: ../../getting-started/next-steps.rst:71
msgid "Starting the worker"
msgstr "ワーカーの起動"

#: ../../getting-started/next-steps.rst:73
msgid "The :program:`celery` program can be used to start the worker:"
msgstr "ワーカーの起動には :program:`celery` プログラムを使用します::"

#: ../../getting-started/next-steps.rst:79
msgid "When the worker starts you should see a banner and some messages::"
msgstr "ワーカーが起動すると、バナーとメッセージが表示されます::"

#: ../../getting-started/next-steps.rst:95
msgid ""
"-- The *broker* is the URL you specifed in the broker argument in our "
"``celery`` module, you can also specify a different broker on the command-"
"line by using the :option:`-b` option."
msgstr ""
"-- *broker* は ``celery`` モジュールに broker 引数として指定した URL です。"
"コマンドラインで :option:`-b` オプションを使って別のブローカーを指定することもできます。"

#: ../../getting-started/next-steps.rst:99
msgid ""
"-- *Concurrency* is the number of prefork worker process used to process "
"your tasks concurrently, when all of these are busy doing work new tasks "
"will have to wait for one of the tasks to finish before it can be processed."
msgstr ""
"-- *Concurrency* はプリフォークされるワーカープロセスの数で、同時にタスクを処理する数になります。"
"すべてのワーカープロセスが処理中の場合、新しいタスクは他のタスクが完了するまで待たなくてはいけません。"

#: ../../getting-started/next-steps.rst:104
msgid ""
"The default concurrency number is the number of CPU's on that machine "
"(including cores), you can specify a custom number using :option:`-c` "
"option. There is no recommended value, as the optimal number depends on a "
"number of factors, but if your tasks are mostly I/O-bound then you can try "
"to increase it, experimentation has shown that adding more than twice the "
"number of CPU's is rarely effective, and likely to degrade performance "
"instead."
msgstr ""
"デフォルトの concurrency 数はマシンの CPU (Core も含む) 数です。"
":option:`-c` オプションでこの数を指定できます。"
"この推奨値はありません。と言うのも、様々な要素によって最適な数が変わってくるからですが、"
"タスクが主に I/O バウンドであれば数を増やしてみるといいかもしれません。"
"しかし実験では CPU 数の 2 倍以上にしてもほとんど効果はなく、むしろパフォーマンスが"
"下がる傾向が見られました。"

#: ../../getting-started/next-steps.rst:112
msgid ""
"Including the default prefork pool, Celery also supports using Eventlet, "
"Gevent, and threads (see :ref:`concurrency`)."
msgstr ""
"デフォルトのプリフォークプールの他に、Eventlet、Gevent、スレッドもサポートしています。"
"(:ref:`concurrency` を参照)"

#: ../../getting-started/next-steps.rst:115
msgid ""
"-- *Events* is an option that when enabled causes Celery to send monitoring "
"messages (events) for actions occurring in the worker. These can be used by "
"monitor programs like ``celery events``, and Flower - the real-time Celery "
"monitor, which you can read about in the :ref:`Monitoring and Management "
"guide <guide-monitoring>`."
msgstr ""
"-- *Events* はワーカーで発生したアクションの監視メッセージ(イベント)を Celery に"
"送信させるオプションです。イベントは、``celery events`` や Flower - リアルタイムの"
"Celery モニター - といった監視プログラムで使われます。"
"詳しくは :ref:`Monitoring and Management guide <guide-monitoring>` を読んでください。"

#: ../../getting-started/next-steps.rst:121
msgid ""
"-- *Queues* is the list of queues that the worker will consume tasks from.  "
"The worker can be told to consume from several queues at once, and this is "
"used to route messages to specific workers as a means for Quality of "
"Service, separation of concerns, and emulating priorities, all described in "
"the :ref:`Routing Guide <guide-routing>`."
msgstr ""
"-- *Queues* はワーカーがタスクを取得してくるキューのリストです。"
"一度にいくつかのキューからタスクを取得するようにワーカーに指示することもできます。"
"これは Quality of Service や separation of concerns、優先度のエミュレートを実現する"
"手段として特定のワーカーにメッセージを送るのに使用されます。"
":ref:`Routing Guide <guide-routing>` に詳細がまとめられています。"

#: ../../getting-started/next-steps.rst:128
msgid ""
"You can get a complete list of command-line arguments by passing in the "
"`--help` flag:"
msgstr ""
"コマンドライン引数の全リストを見るには、`--help` フラグを渡します::"

#: ../../getting-started/next-steps.rst:135
msgid ""
"These options are described in more detailed in the :ref:`Workers Guide "
"<guide-workers>`."
msgstr ""
"それぞれのオプションについては :ref:`Workers Guide <guide-workers>` に記載されています。"

#: ../../getting-started/next-steps.rst:138
msgid "Stopping the worker"
msgstr "ワーカーの停止"

#: ../../getting-started/next-steps.rst:140
msgid ""
"To stop the worker simply hit Ctrl+C.  A list of signals supported by the "
"worker is detailed in the :ref:`Workers Guide <guide-workers>`."
msgstr ""
"ワーカーを停止するには Ctrl+C を叩くだけです。ワーカーがサポートしているシグナルのリストは"
" :ref:`Workers Guide <guide-workers>` に記載されています。"

#: ../../getting-started/next-steps.rst:144
msgid "In the background"
msgstr "バックグラウンドで"

#: ../../getting-started/next-steps.rst:146
msgid ""
"In production you will want to run the worker in the background, this is "
"described in detail in the :ref:`daemonization tutorial <daemonizing>`."
msgstr ""
"運用環境においてはワーカーをバックグラウンドで稼動させておきたいことでしょう。"
"この詳細については :ref:`daemonization tutorial <daemonizing>` を参照してください。"

#: ../../getting-started/next-steps.rst:149
msgid ""
"The daemonization scripts uses the :program:`celery multi` command to start "
"one or more workers in the background:"
msgstr ""
"デーモン化スクリプトでは、ひとつ、もしくは複数のワーカーをバックグラウンドで起動するために"
" :program:`celery multi` コマンドを使用します。"

#: ../../getting-started/next-steps.rst:159
msgid "You can restart it too:"
msgstr "再起動もできます:"

#: ../../getting-started/next-steps.rst:174
msgid "or stop it:"
msgstr "停止することも:"

#: ../../getting-started/next-steps.rst:180
msgid ""
"The ``stop`` command is asynchronous so it will not wait for the worker to "
"shutdown.  You will probably want to use the ``stopwait`` command instead "
"which will ensure all currently executing tasks is completed:"
msgstr ""
"``stop`` コマンドは非同期なのでワーカーが停止するまで待ちません。``stopwait`` コマンドを使えば"
"現在実行中の全タスクが完了するのを待って終了します。"

#: ../../getting-started/next-steps.rst:190
msgid ""
":program:`celery multi` doesn't store information about workers so you need "
"to use the same command-line arguments when restarting.  Only the same "
"pidfile and logfile arguments must be used when stopping."
msgstr ""
":program:`celery multi` はワーカーの情報を保存しないので、再起動の際は同じコマンドライン引数を付ける必要があります。"
"停止する際は pidfile と logfile の二つの引数だけを起動時と同じにします。"

#: ../../getting-started/next-steps.rst:195
msgid ""
"By default it will create pid and log files in the current directory, to "
"protect against multiple workers launching on top of each other you are "
"encouraged to put these in a dedicated directory:"
msgstr ""
"デフォルトではカレントディレクトリ上に pid とログファイルを生成しますが、"
"複数のワーカーが重複して起動してしまうことを防ぐため、専用のディレクトリを用意して、"
"そこに pid とログファイルを生成するようにします:"

#: ../../getting-started/next-steps.rst:206
msgid ""
"With the multi command you can start multiple workers, and there is a "
"powerful command-line syntax to specify arguments for different workers too,"
" e.g:"
msgstr ""

#: ../../getting-started/next-steps.rst:215
msgid ""
"For more examples see the :mod:`~celery.bin.multi` module in the API "
"reference."
msgstr ""
"API リファレンスの :mod:`~celery.bin.multi` モジュールに、その他の例が掲載されています。"

#: ../../getting-started/next-steps.rst:221
msgid "About the :option:`--app` argument"
msgstr ":option:`--app` 引数について"

#: ../../getting-started/next-steps.rst:223
msgid ""
"The :option:`--app` argument specifies the Celery app instance to use, it "
"must be in the form of ``module.path:attribute``"
msgstr ""
":option:`--app` 引数では使用する Celery の app インスタンスを "
"``module.path:attribute`` の形式で指定します。"

#: ../../getting-started/next-steps.rst:226
msgid ""
"But it also supports a shortcut form If only a package name is specified, "
"where it'll try to search for the app instance, in the following order:"
msgstr ""
"パッケージ名のみが指定するショートカット形式もサポートされており、次の順序で app インスタンスを探索します:"

#: ../../getting-started/next-steps.rst:229
msgid "With ``--app=proj``:"
msgstr "``--app=proj`` の場合:"

#: ../../getting-started/next-steps.rst:231
msgid "an attribute named ``proj.app``, or"
msgstr "``proj.app`` という名前の属性"

#: ../../getting-started/next-steps.rst:232
msgid "an attribute named ``proj.celery``, or"
msgstr "``proj.celery`` という名前の属性"

#: ../../getting-started/next-steps.rst:233
msgid ""
"any attribute in the module ``proj`` where the value is a Celery "
"application, or"
msgstr "``proj`` モジュール内の Celery インスタンスが値になっている属性"

#: ../../getting-started/next-steps.rst:236
msgid ""
"If none of these are found it'll try a submodule named ``proj.celery``:"
msgstr ""
"上のフローで見つからなかった場合、今度は ``proj.celery`` という名前のサブモジュールを探索します:"

#: ../../getting-started/next-steps.rst:238
msgid "an attribute named ``proj.celery.app``, or"
msgstr "``proj.celery.app`` という名前の属性"

#: ../../getting-started/next-steps.rst:239
msgid "an attribute named ``proj.celery.celery``, or"
msgstr "``proj.celery.celery`` という名前の属性"

#: ../../getting-started/next-steps.rst:240
msgid ""
"Any atribute in the module ``proj.celery`` where the value is a Celery "
"application."
msgstr ""
"``proj.celery`` モジュール内の Celery インタンスが値になっている属性"

#: ../../getting-started/next-steps.rst:243
msgid ""
"This scheme mimics the practices used in the documentation, i.e. "
"``proj:app`` for a single contained module, and ``proj.celery:app`` for "
"larger projects."
msgstr "このスキームはこのドキュメントでも使われているプラクティスに似ています。"
"具体的に言うと、単一モジュールで構成されるプロジェクトでは ``proj:app`` を使い、"
"大きめのプロジェクトでは ``proj.celery:app`` を使っている点です。"

#: ../../getting-started/next-steps.rst:251
msgid "Calling Tasks"
msgstr "タスクの呼び出し"

#: ../../getting-started/next-steps.rst:253
msgid "You can call a task using the :meth:`delay` method::"
msgstr ":meth:`delay` メソッドを使ってタスクを呼び出します::"

#: ../../getting-started/next-steps.rst:257
msgid ""
"This method is actually a star-argument shortcut to another method called "
":meth:`apply_async`::"
msgstr ""
"このメソッドは実際には :meth:`apply_asyc` メソッドを star-argument を用いて呼び出しているショートカットです::"

#: ../../getting-started/next-steps.rst:262
msgid ""
"The latter enables you to specify execution options like the time to run "
"(countdown), the queue it should be sent to and so on::"
msgstr ""
"後者の呼び出しでは、実行時間(countdown)や送信されるキューなどの実行時オプションを指定できます::"

#: ../../getting-started/next-steps.rst:267
msgid ""
"In the above example the task will be sent to a queue named ``lopri`` and "
"the task will execute, at the earliest, 10 seconds after the message was "
"sent."
msgstr ""
"上の例では、タスクは ``lopri`` という名前のキューに送られ、メッセージ送信から最速で 10 秒後にタスクが実行されます。"

#: ../../getting-started/next-steps.rst:270
msgid ""
"Applying the task directly will execute the task in the current process, so "
"that no message is sent::"
msgstr ""
"タスクを直接呼び出すと、メッセージは送信されず、そのプロセスの中で実行されます::"

#: ../../getting-started/next-steps.rst:276
msgid ""
"These three methods - :meth:`delay`, :meth:`apply_async`, and applying "
"(``__call__``), represents the Celery calling API, which are also used for "
"subtasks."
msgstr ""
"これら 3 つのメソッド - :meth:`delay`、:meth:`apply_async`、applying (``__call__``) は "
"Celery Calling API と称され、サブタスクでも使用されます。"

#: ../../getting-started/next-steps.rst:280
msgid ""
"A more detailed overview of the Calling API can be found in the "
":ref:`Calling User Guide <guide-calling>`."
msgstr ""
"Calling API についてのより詳細な解説は :ref:`Calling User Guide <guide-calling>` にあります。"

#: ../../getting-started/next-steps.rst:283
msgid ""
"Every task invocation will be given a unique identifier (an UUID), this is "
"the task id."
msgstr ""
"あらゆるタスクの呼び出しにはユニークな ID (UUID) が付与されます。これがタスク ID です。"

#: ../../getting-started/next-steps.rst:286
msgid ""
"The ``delay`` and ``apply_async`` methods return an :class:`~@AsyncResult` "
"instance, which can be used to keep track of the tasks execution state. But "
"for this you need to enable a :ref:`result backend <task-result-backends>` "
"so that the state can be stored somewhere."
msgstr ""
"``delay`` と ``apply_async`` メソッドは :class:`~@AsyncResult` インスタンスを返します。"
"このインスタンスを使ってタスクの実行状態を追跡できますが、この状態を保存するために"
" :ref:`result backend <task-result-backends>` を有効にする必要があります。"

#: ../../getting-started/next-steps.rst:291
msgid ""
"Results are disabled by default because of the fact that there is no result "
"backend that suits every application, so to choose one you need to consider "
"the drawbacks of each individual backend.  For many tasks keeping the return"
" value isn't even very useful, so it's a sensible default to have.  Also "
"note that result backends are not used for monitoring tasks and workers, for"
" that Celery uses dedicated event messages (see :ref:`guide-monitoring`)."
msgstr ""
"デフォルトでは結果バックエンドは無効になっていますが、これはほとんどのアプリケーションにとっては"
"適切なものだからです。有効にする場合は、使用するバックエンドを短所も考慮して選んでください。"
"大半のタスクでは結果を保持しておくことが大して有用ではないので、デフォルトで無効になっているのは"
"良い設計と言えるでしょう。"
"また、結果バックエンドはタスクやワーカーを監視するために使うものではないということに注意してください。"
"監視用途としては Celery はイベントメッセージを使います(:ref:`guide-monitoring`)。"

#: ../../getting-started/next-steps.rst:298
msgid ""
"If you have a result backend configured you can retrieve the return value of"
" a task::"
msgstr ""
"結果バックエンドを設定すると、タスクの戻り値を取得できるようになります::"

#: ../../getting-started/next-steps.rst:305
msgid "You can find the task's id by looking at the :attr:`id` attribute::"
msgstr ":attr:`id` 属性を調べればタスク ID が分かります::"

#: ../../getting-started/next-steps.rst:310
msgid ""
"You can also inspect the exception and traceback if the task raised an "
"exception, in fact ``result.get()`` will propagate any errors by default::"
msgstr ""
"また、タスクが例外を送出したた場合にはその例外やトレースバックを調べることもできます。"
"デフォルトでは ``result.get()`` がすべてのエラーを伝搬します。"

#: ../../getting-started/next-steps.rst:323
msgid ""
"If you don't wish for the errors to propagate then you can disable that by "
"passing the ``propagate`` argument::"
msgstr ""
"エラーの伝搬をして欲しくない場合は ``propaage`` 引数によって無効にできます::"

#: ../../getting-started/next-steps.rst:329
msgid ""
"In this case it will return the exception instance raised instead, and so to"
" check whether the task succeeded or failed you will have to use the "
"corresponding methods on the result instance::"
msgstr ""
"この場合、exception インスタンスが戻り値となります。タスクの実行が成功したか失敗したかを"
"結果インタンスの該当するメソッドを使ってチェックしなければいけません::"

#: ../../getting-started/next-steps.rst:339
msgid ""
"So how does it know if the task has failed or not?  It can find out by "
"looking at the tasks *state*::"
msgstr ""
"タスクが失敗したかどうかは、タスクの *state* を調べることで分かります::"

#: ../../getting-started/next-steps.rst:345
msgid ""
"A task can only be in a single state, but it can progress through several "
"states. The stages of a typical task can be::"
msgstr ""
"タスクはひとつののみ状態を取り得ますが、いくつかの状態を遷移します。典型的なタスクでは次のような遷移です::"

#: ../../getting-started/next-steps.rst:350
msgid ""
"The started state is a special state that is only recorded if the "
":setting:`CELERY_TRACK_STARTED` setting is enabled, or if the "
"``@task(track_started=True)`` option is set for the task."
msgstr ""

#: ../../getting-started/next-steps.rst:354
msgid ""
"The pending state is actually not a recorded state, but rather the default "
"state for any task id that is unknown, which you can see from this example::"
msgstr ""

#: ../../getting-started/next-steps.rst:364
msgid ""
"If the task is retried the stages can become even more complex, e.g, for a "
"task that is retried two times the stages would be::"
msgstr ""

#: ../../getting-started/next-steps.rst:369
msgid ""
"To read more about task states you should see the :ref:`task-states` section"
" in the tasks user guide."
msgstr ""

#: ../../getting-started/next-steps.rst:372
msgid ""
"Calling tasks is described in detail in the :ref:`Calling Guide <guide-"
"calling>`."
msgstr ""

#: ../../getting-started/next-steps.rst:378
msgid "*Canvas*: Designing Workflows"
msgstr "*Canvas*: 設計ワークフロー"

#: ../../getting-started/next-steps.rst:380
msgid ""
"You just learned how to call a task using the tasks ``delay`` method, and "
"this is often all you need, but sometimes you may want to pass the signature"
" of a task invocation to another process or as an argument to another "
"function, for this Celery uses something called *subtasks*."
msgstr ""
"ここまで ``delay`` メソッドを使ってタスクを呼び出す方法について学びました。"
"これで大半のケースにおいて必要なものはすべて賄えているのですが、"
"タスクの呼び出しシグニチャーを別のプロセスに渡したり、引数として別の関数に渡したいケースが"
"生じることがあります。これを解決するのが *サブタスク* と呼ばれるものです。"

#: ../../getting-started/next-steps.rst:385
msgid ""
"A subtask wraps the arguments and execution options of a single task "
"invocation in a way such that it can be passed to functions or even "
"serialized and sent across the wire."
msgstr ""
"サブタスクは、あるタスク呼び出しの引数や実行時オプションをラップしたもので、"
"関数に渡したり、シリアライズしてネットワーク上に送信したりするのに使われます。"

#: ../../getting-started/next-steps.rst:389
msgid ""
"You can create a subtask for the ``add`` task using the arguments ``(2, "
"2)``, and a countdown of 10 seconds like this::"
msgstr ""
"``add`` タスクに引数 ``(2, 2)`` を指定し、10 秒の countdown オプションを付けた"
"サブタスクを生成するには次のようにします::"

#: ../../getting-started/next-steps.rst:395
msgid "There is also a shortcut using star arguments::"
msgstr "star arguments を使ったショートカットもあります::"

#: ../../getting-started/next-steps.rst:401
msgid "And there's that calling API again…"
msgstr "Calling API 再び…"

#: ../../getting-started/next-steps.rst:403
msgid ""
"Subtask instances also supports the calling API, which means that they have "
"the ``delay`` and ``apply_async`` methods."
msgstr ""
"サブタスクのインスタンスも Calling API をサポートしています。"
"つまり、``delay`` と ``apply_async`` メソッドが利用できます。"

#: ../../getting-started/next-steps.rst:406
msgid ""
"But there is a difference in that the subtask may already have an argument "
"signature specified.  The ``add`` task takes two arguments, so a subtask "
"specifying two arguments would make a complete signature::"
msgstr ""
"サブタスクではすでに引数シグニチャーが指定されている点が異なります。"
"``add`` タスクは 2 つの引数を取るので、2 つの引数が指定されたサブタスクは完全なシグニチャーを備えていることになります::"

#: ../../getting-started/next-steps.rst:415
msgid ""
"But, you can also make incomplete signatures to create what we call "
"*partials*::"
msgstr ""
"一方、不完全なシグニチャーを持たせることもでき、これを *パーシャル* と呼んでいます::"

#: ../../getting-started/next-steps.rst:421
msgid ""
"``s2`` is now a partial subtask that needs another argument to be complete, "
"and this can be resolved when calling the subtask::"
msgstr ""
"``s2`` は現時点ではパーシャルなサブタスクで、完全なものになるにはもう 1 つの引数が必要ですが、"
"これはサブタスクを呼び出す時に行えます::"

#: ../../getting-started/next-steps.rst:429
msgid ""
"Here you added the argument 8, which was prepended to the existing argument "
"2 forming a complete signature of ``add(8, 2)``."
msgstr ""
"このように引数 8 を既存の引数 2 の前に加えたので、``add(8, 2)`` という完全なシグニチャーの形になったわけです。"

#: ../../getting-started/next-steps.rst:432
msgid ""
"Keyword arguments can also be added later, these are then merged with any "
"existing keyword arguments, but with new arguments taking precedence::"
msgstr ""
"キーワード引数も後から追加することができます。既存のキーワード引数にマージされますが、"
"後から追加した新しい引数が優先されます::"

#: ../../getting-started/next-steps.rst:438
msgid "As stated subtasks supports the calling API, which means that:"
msgstr "上述のようにサブタスクは Calling API をサポートします::"

#: ../../getting-started/next-steps.rst:440
msgid "``subtask.apply_async(args=(), kwargs={}, **options)``"
msgstr ""

#: ../../getting-started/next-steps.rst:442
msgid ""
"Calls the subtask with optional partial arguments and partial keyword "
"arguments.  Also supports partial execution options."
msgstr ""
"サブタスクをオプションのパーシャル引数、パーシャルキーワード引数を付けて呼べます。"
"また、パーシャルな実行時オプションもサポートしています。"

#: ../../getting-started/next-steps.rst:445
msgid "``subtask.delay(*args, **kwargs)``"
msgstr ""

#: ../../getting-started/next-steps.rst:447
msgid ""
"Star argument version of ``apply_async``.  Any arguments will be prepended "
"to the arguments in the signature, and keyword arguments is merged with any "
"existing keys."
msgstr ""
"``apply_async`` の Star argument バージョンです。ここで指定した引数は"
"シグニチャーに含まれる引数の前に追加され、キーワード引数は既存の引数にマージされます。"

#: ../../getting-started/next-steps.rst:451
msgid ""
"So this all seems very useful, but what can you actually do with these? To "
"get to that I must introduce the canvas primitives…"
msgstr ""
"これらはとても便利なように見えますが、では一体これらを使って何をするのでしょう？　"
"その答えのためには canvas primitives を紹介しなければいけません…"

#: ../../getting-started/next-steps.rst:455
msgid "The Primitives"
msgstr "Primitives"

#: ../../getting-started/next-steps.rst:0
msgid "\\"
msgstr ""

#: ../../getting-started/next-steps.rst:462
msgid ":ref:`group <canvas-group>`"
msgstr ""

#: ../../getting-started/next-steps.rst:463
msgid ":ref:`chain <canvas-chain>`"
msgstr ""

#: ../../getting-started/next-steps.rst:464
msgid ":ref:`chord <canvas-chord>`"
msgstr ""

#: ../../getting-started/next-steps.rst:465
msgid ":ref:`map <canvas-map>`"
msgstr ""

#: ../../getting-started/next-steps.rst:466
msgid ":ref:`starmap <canvas-map>`"
msgstr ""

#: ../../getting-started/next-steps.rst:467
msgid ":ref:`chunks <canvas-chunks>`"
msgstr ""

#: ../../getting-started/next-steps.rst:469
msgid ""
"The primitives are subtasks themselves, so that they can be combined in any "
"number of ways to compose complex workflows."
msgstr ""

#: ../../getting-started/next-steps.rst:474
msgid ""
"These examples retrieve results, so to try them out you need to configure a "
"result backend. The example project above already does that (see the backend"
" argument to :class:`~celery.Celery`)."
msgstr ""

#: ../../getting-started/next-steps.rst:478
msgid "Let's look at some examples:"
msgstr ""

#: ../../getting-started/next-steps.rst:481
msgid "Groups"
msgstr ""

#: ../../getting-started/next-steps.rst:483
msgid ""
"A :class:`~celery.group` calls a list of tasks in parallel, and it returns a"
" special result instance that lets you inspect the results as a group, and "
"retrieve the return values in order."
msgstr ""

#: ../../getting-started/next-steps.rst:495
msgid "Partial group"
msgstr ""

#: ../../getting-started/next-steps.rst:504
msgid "Chains"
msgstr ""

#: ../../getting-started/next-steps.rst:506
msgid ""
"Tasks can be linked together so that after one task returns the other is "
"called:"
msgstr ""

#: ../../getting-started/next-steps.rst:519
msgid "or a partial chain:"
msgstr ""

#: ../../getting-started/next-steps.rst:529
msgid "Chains can also be written like this:"
msgstr ""

#: ../../getting-started/next-steps.rst:537
msgid "Chords"
msgstr ""

#: ../../getting-started/next-steps.rst:539
msgid "A chord is a group with a callback:"
msgstr ""

#: ../../getting-started/next-steps.rst:550
msgid ""
"A group chained to another task will be automatically converted to a chord:"
msgstr ""

#: ../../getting-started/next-steps.rst:559
msgid ""
"Since these primitives are all of the subtask type they can be combined "
"almost however you want, e.g::"
msgstr ""

#: ../../getting-started/next-steps.rst:564
msgid ""
"Be sure to read more about workflows in the :ref:`Canvas <guide-canvas>` "
"user guide."
msgstr ""

#: ../../getting-started/next-steps.rst:568
msgid "Routing"
msgstr "ルーティング"

#: ../../getting-started/next-steps.rst:570
msgid ""
"Celery supports all of the routing facilities provided by AMQP, but it also "
"supports simple routing where messages are sent to named queues."
msgstr ""
"Celery は AMQP から提供されるルーティングファイリティをすべてサポートしていますが、"
"指定したキューにメッセージを送るシンプルなルーティングもサポートしています。"

#: ../../getting-started/next-steps.rst:573
msgid ""
"The :setting:`CELERY_ROUTES` setting enables you to route tasks by name and "
"keep everything centralized in one location::"
msgstr ""
":settings:`CELERY_ROUTES` 設定で、タスクの名前でルートを指定でき、一カ所にすべてを集めることができます::"

#: ../../getting-started/next-steps.rst:582
msgid ""
"You can also specify the queue at runtime with the ``queue`` argument to "
"``apply_async``::"
msgstr ""
"実行時に ``apply_async`` に対して ``queue`` 引数を用いてキューを指定することも可能です::"

#: ../../getting-started/next-steps.rst:588
msgid ""
"You can then make a worker consume from this queue by specifying the "
":option:`-Q` option:"
msgstr ""
"そして、:option:`-Q` オプションを指定して、ワーカーにこのキューを利用させることができます:"

#: ../../getting-started/next-steps.rst:595
msgid ""
"You may specify multiple queues by using a comma separated list, for example"
" you can make the worker consume from both the default queue, and the "
"``hipri`` queue, where the default queue is named ``celery`` for historical "
"reasons:"
msgstr ""
"コンマ区切りのリストで複数のキューを指定できます。"
"次の例では、デフォルトキューと ``hipri`` キューの両方をワーカーに指定しています。"
"デフォルトキューは力士的な理由で ``celery`` と命名されています:"

#: ../../getting-started/next-steps.rst:604
msgid ""
"The order of the queues doesn't matter as the worker will give equal weight "
"to the queues."
msgstr ""
"ワーカーは指定されたキューに等しいウェイトを置いているため、キューの順番は関係ありません。"

#: ../../getting-started/next-steps.rst:607
msgid ""
"To learn more about routing, including taking use of the full power of AMQP "
"routing, see the :ref:`Routing Guide <guide-routing>`."
msgstr ""
"AMQP ルーティング機能の利用を含め、ルーティングについてもっと学ぶには :ref:`Routing Guide <guide-routing>` を参照してください。"

#: ../../getting-started/next-steps.rst:611
msgid "Remote Control"
msgstr ""

#: ../../getting-started/next-steps.rst:613
msgid ""
"If you're using RabbitMQ (AMQP), Redis or MongoDB as the broker then you can"
" control and inspect the worker at runtime."
msgstr ""

#: ../../getting-started/next-steps.rst:616
msgid "For example you can see what tasks the worker is currently working on:"
msgstr ""

#: ../../getting-started/next-steps.rst:622
msgid ""
"This is implemented by using broadcast messaging, so all remote control "
"commands are received by every worker in the cluster."
msgstr ""

#: ../../getting-started/next-steps.rst:625
msgid ""
"You can also specify one or more workers to act on the request using the "
":option:`--destination` option, which is a comma separated list of worker "
"host names:"
msgstr ""

#: ../../getting-started/next-steps.rst:633
msgid ""
"If a destination is not provided then every worker will act and reply to the"
" request."
msgstr ""

#: ../../getting-started/next-steps.rst:636
msgid ""
"The :program:`celery inspect` command contains commands that does not change"
" anything in the worker, it only replies information and statistics about "
"what is going on inside the worker. For a list of inspect commands you can "
"execute:"
msgstr ""

#: ../../getting-started/next-steps.rst:645
msgid ""
"Then there is the :program:`celery control` command, which contains commands"
" that actually changes things in the worker at runtime:"
msgstr ""

#: ../../getting-started/next-steps.rst:652
msgid ""
"For example you can force workers to enable event messages (used for "
"monitoring tasks and workers):"
msgstr ""

#: ../../getting-started/next-steps.rst:659
msgid ""
"When events are enabled you can then start the event dumper to see what the "
"workers are doing:"
msgstr ""

#: ../../getting-started/next-steps.rst:666
msgid "or you can start the curses interface:"
msgstr ""

#: ../../getting-started/next-steps.rst:672
msgid "when you're finished monitoring you can disable events again:"
msgstr ""

#: ../../getting-started/next-steps.rst:678
msgid ""
"The :program:`celery status` command also uses remote control commands and "
"shows a list of online workers in the cluster:"
msgstr ""

#: ../../getting-started/next-steps.rst:685
msgid ""
"You can read more about the :program:`celery` command and monitoring in the "
":ref:`Monitoring Guide <guide-monitoring>`."
msgstr ""

#: ../../getting-started/next-steps.rst:689
msgid "Timezone"
msgstr ""

#: ../../getting-started/next-steps.rst:691
msgid "All times and dates, internally and in messages uses the UTC timezone."
msgstr ""

#: ../../getting-started/next-steps.rst:693
msgid ""
"When the worker receives a message, for example with a countdown set it "
"converts that UTC time to local time.  If you wish to use a different "
"timezone than the system timezone then you must configure that using the "
":setting:`CELERY_TIMEZONE` setting::"
msgstr ""

#: ../../getting-started/next-steps.rst:701
msgid "Optimization"
msgstr "最適化"

#: ../../getting-started/next-steps.rst:703
msgid ""
"The default configuration is not optimized for throughput by default, it "
"tries to walk the middle way between many short tasks and fewer long tasks, "
"a compromise between throughput and fair scheduling."
msgstr ""
"デフォルトの設定はスループットのための最適化はされていません。"
"デフォルト設定は多くの短いタスクと少量の長いタスクの中間を行くように意図されており、"
"スループットと正確なスケジューリングとの妥協を図ったものです。"

#: ../../getting-started/next-steps.rst:707
msgid ""
"If you have strict fair scheduling requirements, or want to optimize for "
"throughput then you should read the :ref:`Optimizing Guide <guide-"
"optimizing>`."
msgstr ""
"厳密なスケジューリングな要件がある、またはスループットを高めるように最適化したい、といった場合は"
":ref:`Optimizing Guide <guide-optimizing>` を読んでください。"

#: ../../getting-started/next-steps.rst:711
msgid ""
"If you're using RabbitMQ then you should install the :mod:`librabbitmq` "
"module, which is an AMQP client implemented in C:"
msgstr ""
"RabbitMQ を使っているのであれば、C で実装された AMQP クライアントである "
":mod:`librabbitmq` モジュールをインストールするべきです。"

#: ../../getting-started/next-steps.rst:719
msgid "What to do now?"
msgstr "さあ次は？"

#: ../../getting-started/next-steps.rst:721
msgid ""
"Now that you have read this document you should continue to the :ref:`User "
"Guide <guide>`."
msgstr ""
"このドキュメントを読み終わったので、次は :ref:`User Guide <guide>` に進みましょう。"

#: ../../getting-started/next-steps.rst:724
msgid "There's also an :ref:`API reference <apiref>` if you are so inclined."
msgstr ":ref:`API reference <apiref>` もありますよ。"
