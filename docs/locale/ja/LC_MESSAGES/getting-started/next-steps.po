# 
msgid ""
msgstr ""
"Project-Id-Version: Celery 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-10 16:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../getting-started/next-steps.rst:5
msgid "Next Steps"
msgstr ""

#: ../../getting-started/next-steps.rst:7
msgid ""
"The :ref:`first-steps` guide is intentionally minimal.  In this guide I will"
" demonstrate what Celery offers in more detail, including how to add Celery "
"support for your application and library."
msgstr ""

#: ../../getting-started/next-steps.rst:11
msgid ""
"This document does not document all of Celery's features and best practices,"
" so it's recommended that you also read the :ref:`User Guide <guide>`"
msgstr ""

#: ../../getting-started/next-steps.rst:20
msgid "Using Celery in your Application"
msgstr ""

#: ../../getting-started/next-steps.rst:25
msgid "Our Project"
msgstr ""

#: ../../getting-started/next-steps.rst:27
msgid "Project layout::"
msgstr ""

#: ../../getting-started/next-steps.rst:34
msgid ":file:`proj/celery.py`"
msgstr ""

#: ../../getting-started/next-steps.rst:39
msgid ""
"In this module you created our :class:`@Celery` instance (sometimes referred"
" to as the *app*).  To use Celery within your project you simply import this"
" instance."
msgstr ""

#: ../../getting-started/next-steps.rst:43
msgid "The ``broker`` argument specifies the URL of the broker to use."
msgstr ""

#: ../../getting-started/next-steps.rst:45
msgid "See :ref:`celerytut-broker` for more information."
msgstr ""

#: ../../getting-started/next-steps.rst:47
msgid "The ``backend`` argument specifies the result backend to use,"
msgstr ""

#: ../../getting-started/next-steps.rst:49
msgid ""
"It's used to keep track of task state and results. While results are "
"disabled by default I use the amqp result backend here because I demonstrate"
" how retrieving results work later, you may want to use a different backend "
"for your application. They all have different strengths and weaknesses.  If "
"you don't need results it's better to disable them.  Results can also be "
"disabled for individual tasks by setting the ``@task(ignore_result=True)`` "
"option."
msgstr ""

#: ../../getting-started/next-steps.rst:57
msgid "See :ref:`celerytut-keeping-results` for more information."
msgstr ""

#: ../../getting-started/next-steps.rst:59
msgid ""
"The ``include`` argument is a list of modules to import when the worker "
"starts.  You need to add our tasks module here so that the worker is able to"
" find our tasks."
msgstr ""

#: ../../getting-started/next-steps.rst:64
msgid ":file:`proj/tasks.py`"
msgstr ""

#: ../../getting-started/next-steps.rst:71
msgid "Starting the worker"
msgstr ""

#: ../../getting-started/next-steps.rst:73
msgid "The :program:`celery` program can be used to start the worker:"
msgstr ""

#: ../../getting-started/next-steps.rst:79
msgid "When the worker starts you should see a banner and some messages::"
msgstr ""

#: ../../getting-started/next-steps.rst:95
msgid ""
"-- The *broker* is the URL you specifed in the broker argument in our "
"``celery`` module, you can also specify a different broker on the command-"
"line by using the :option:`-b` option."
msgstr ""

#: ../../getting-started/next-steps.rst:99
msgid ""
"-- *Concurrency* is the number of prefork worker process used to process "
"your tasks concurrently, when all of these are busy doing work new tasks "
"will have to wait for one of the tasks to finish before it can be processed."
msgstr ""

#: ../../getting-started/next-steps.rst:104
msgid ""
"The default concurrency number is the number of CPU's on that machine "
"(including cores), you can specify a custom number using :option:`-c` "
"option. There is no recommended value, as the optimal number depends on a "
"number of factors, but if your tasks are mostly I/O-bound then you can try "
"to increase it, experimentation has shown that adding more than twice the "
"number of CPU's is rarely effective, and likely to degrade performance "
"instead."
msgstr ""

#: ../../getting-started/next-steps.rst:112
msgid ""
"Including the default prefork pool, Celery also supports using Eventlet, "
"Gevent, and threads (see :ref:`concurrency`)."
msgstr ""

#: ../../getting-started/next-steps.rst:115
msgid ""
"-- *Events* is an option that when enabled causes Celery to send monitoring "
"messages (events) for actions occurring in the worker. These can be used by "
"monitor programs like ``celery events``, and Flower - the real-time Celery "
"monitor, which you can read about in the :ref:`Monitoring and Management "
"guide <guide-monitoring>`."
msgstr ""

#: ../../getting-started/next-steps.rst:121
msgid ""
"-- *Queues* is the list of queues that the worker will consume tasks from.  "
"The worker can be told to consume from several queues at once, and this is "
"used to route messages to specific workers as a means for Quality of "
"Service, separation of concerns, and emulating priorities, all described in "
"the :ref:`Routing Guide <guide-routing>`."
msgstr ""

#: ../../getting-started/next-steps.rst:128
msgid ""
"You can get a complete list of command-line arguments by passing in the "
"`--help` flag:"
msgstr ""

#: ../../getting-started/next-steps.rst:135
msgid ""
"These options are described in more detailed in the :ref:`Workers Guide "
"<guide-workers>`."
msgstr ""

#: ../../getting-started/next-steps.rst:138
msgid "Stopping the worker"
msgstr ""

#: ../../getting-started/next-steps.rst:140
msgid ""
"To stop the worker simply hit Ctrl+C.  A list of signals supported by the "
"worker is detailed in the :ref:`Workers Guide <guide-workers>`."
msgstr ""

#: ../../getting-started/next-steps.rst:144
msgid "In the background"
msgstr ""

#: ../../getting-started/next-steps.rst:146
msgid ""
"In production you will want to run the worker in the background, this is "
"described in detail in the :ref:`daemonization tutorial <daemonizing>`."
msgstr ""

#: ../../getting-started/next-steps.rst:149
msgid ""
"The daemonization scripts uses the :program:`celery multi` command to start "
"one or more workers in the background:"
msgstr ""

#: ../../getting-started/next-steps.rst:159
msgid "You can restart it too:"
msgstr ""

#: ../../getting-started/next-steps.rst:174
msgid "or stop it:"
msgstr ""

#: ../../getting-started/next-steps.rst:180
msgid ""
"The ``stop`` command is asynchronous so it will not wait for the worker to "
"shutdown.  You will probably want to use the ``stopwait`` command instead "
"which will ensure all currently executing tasks is completed:"
msgstr ""

#: ../../getting-started/next-steps.rst:190
msgid ""
":program:`celery multi` doesn't store information about workers so you need "
"to use the same command-line arguments when restarting.  Only the same "
"pidfile and logfile arguments must be used when stopping."
msgstr ""

#: ../../getting-started/next-steps.rst:195
msgid ""
"By default it will create pid and log files in the current directory, to "
"protect against multiple workers launching on top of each other you are "
"encouraged to put these in a dedicated directory:"
msgstr ""

#: ../../getting-started/next-steps.rst:206
msgid ""
"With the multi command you can start multiple workers, and there is a "
"powerful command-line syntax to specify arguments for different workers too,"
" e.g:"
msgstr ""

#: ../../getting-started/next-steps.rst:215
msgid ""
"For more examples see the :mod:`~celery.bin.multi` module in the API "
"reference."
msgstr ""

#: ../../getting-started/next-steps.rst:221
msgid "About the :option:`--app` argument"
msgstr ""

#: ../../getting-started/next-steps.rst:223
msgid ""
"The :option:`--app` argument specifies the Celery app instance to use, it "
"must be in the form of ``module.path:attribute``"
msgstr ""

#: ../../getting-started/next-steps.rst:226
msgid ""
"But it also supports a shortcut form If only a package name is specified, "
"where it'll try to search for the app instance, in the following order:"
msgstr ""

#: ../../getting-started/next-steps.rst:229
msgid "With ``--app=proj``:"
msgstr ""

#: ../../getting-started/next-steps.rst:231
msgid "an attribute named ``proj.app``, or"
msgstr ""

#: ../../getting-started/next-steps.rst:232
msgid "an attribute named ``proj.celery``, or"
msgstr ""

#: ../../getting-started/next-steps.rst:233
msgid ""
"any attribute in the module ``proj`` where the value is a Celery "
"application, or"
msgstr ""

#: ../../getting-started/next-steps.rst:236
msgid ""
"If none of these are found it'll try a submodule named ``proj.celery``:"
msgstr ""

#: ../../getting-started/next-steps.rst:238
msgid "an attribute named ``proj.celery.app``, or"
msgstr ""

#: ../../getting-started/next-steps.rst:239
msgid "an attribute named ``proj.celery.celery``, or"
msgstr ""

#: ../../getting-started/next-steps.rst:240
msgid ""
"Any atribute in the module ``proj.celery`` where the value is a Celery "
"application."
msgstr ""

#: ../../getting-started/next-steps.rst:243
msgid ""
"This scheme mimics the practices used in the documentation, i.e. "
"``proj:app`` for a single contained module, and ``proj.celery:app`` for "
"larger projects."
msgstr ""

#: ../../getting-started/next-steps.rst:251
msgid "Calling Tasks"
msgstr ""

#: ../../getting-started/next-steps.rst:253
msgid "You can call a task using the :meth:`delay` method::"
msgstr ""

#: ../../getting-started/next-steps.rst:257
msgid ""
"This method is actually a star-argument shortcut to another method called "
":meth:`apply_async`::"
msgstr ""

#: ../../getting-started/next-steps.rst:262
msgid ""
"The latter enables you to specify execution options like the time to run "
"(countdown), the queue it should be sent to and so on::"
msgstr ""

#: ../../getting-started/next-steps.rst:267
msgid ""
"In the above example the task will be sent to a queue named ``lopri`` and "
"the task will execute, at the earliest, 10 seconds after the message was "
"sent."
msgstr ""

#: ../../getting-started/next-steps.rst:270
msgid ""
"Applying the task directly will execute the task in the current process, so "
"that no message is sent::"
msgstr ""

#: ../../getting-started/next-steps.rst:276
msgid ""
"These three methods - :meth:`delay`, :meth:`apply_async`, and applying "
"(``__call__``), represents the Celery calling API, which are also used for "
"subtasks."
msgstr ""

#: ../../getting-started/next-steps.rst:280
msgid ""
"A more detailed overview of the Calling API can be found in the "
":ref:`Calling User Guide <guide-calling>`."
msgstr ""

#: ../../getting-started/next-steps.rst:283
msgid ""
"Every task invocation will be given a unique identifier (an UUID), this is "
"the task id."
msgstr ""

#: ../../getting-started/next-steps.rst:286
msgid ""
"The ``delay`` and ``apply_async`` methods return an :class:`~@AsyncResult` "
"instance, which can be used to keep track of the tasks execution state. But "
"for this you need to enable a :ref:`result backend <task-result-backends>` "
"so that the state can be stored somewhere."
msgstr ""

#: ../../getting-started/next-steps.rst:291
msgid ""
"Results are disabled by default because of the fact that there is no result "
"backend that suits every application, so to choose one you need to consider "
"the drawbacks of each individual backend.  For many tasks keeping the return"
" value isn't even very useful, so it's a sensible default to have.  Also "
"note that result backends are not used for monitoring tasks and workers, for"
" that Celery uses dedicated event messages (see :ref:`guide-monitoring`)."
msgstr ""

#: ../../getting-started/next-steps.rst:298
msgid ""
"If you have a result backend configured you can retrieve the return value of"
" a task::"
msgstr ""

#: ../../getting-started/next-steps.rst:305
msgid "You can find the task's id by looking at the :attr:`id` attribute::"
msgstr ""

#: ../../getting-started/next-steps.rst:310
msgid ""
"You can also inspect the exception and traceback if the task raised an "
"exception, in fact ``result.get()`` will propagate any errors by default::"
msgstr ""

#: ../../getting-started/next-steps.rst:323
msgid ""
"If you don't wish for the errors to propagate then you can disable that by "
"passing the ``propagate`` argument::"
msgstr ""

#: ../../getting-started/next-steps.rst:329
msgid ""
"In this case it will return the exception instance raised instead, and so to"
" check whether the task succeeded or failed you will have to use the "
"corresponding methods on the result instance::"
msgstr ""

#: ../../getting-started/next-steps.rst:339
msgid ""
"So how does it know if the task has failed or not?  It can find out by "
"looking at the tasks *state*::"
msgstr ""

#: ../../getting-started/next-steps.rst:345
msgid ""
"A task can only be in a single state, but it can progress through several "
"states. The stages of a typical task can be::"
msgstr ""

#: ../../getting-started/next-steps.rst:350
msgid ""
"The started state is a special state that is only recorded if the "
":setting:`CELERY_TRACK_STARTED` setting is enabled, or if the "
"``@task(track_started=True)`` option is set for the task."
msgstr ""

#: ../../getting-started/next-steps.rst:354
msgid ""
"The pending state is actually not a recorded state, but rather the default "
"state for any task id that is unknown, which you can see from this example::"
msgstr ""

#: ../../getting-started/next-steps.rst:364
msgid ""
"If the task is retried the stages can become even more complex, e.g, for a "
"task that is retried two times the stages would be::"
msgstr ""

#: ../../getting-started/next-steps.rst:369
msgid ""
"To read more about task states you should see the :ref:`task-states` section"
" in the tasks user guide."
msgstr ""

#: ../../getting-started/next-steps.rst:372
msgid ""
"Calling tasks is described in detail in the :ref:`Calling Guide <guide-"
"calling>`."
msgstr ""

#: ../../getting-started/next-steps.rst:378
msgid "*Canvas*: Designing Workflows"
msgstr ""

#: ../../getting-started/next-steps.rst:380
msgid ""
"You just learned how to call a task using the tasks ``delay`` method, and "
"this is often all you need, but sometimes you may want to pass the signature"
" of a task invocation to another process or as an argument to another "
"function, for this Celery uses something called *subtasks*."
msgstr ""

#: ../../getting-started/next-steps.rst:385
msgid ""
"A subtask wraps the arguments and execution options of a single task "
"invocation in a way such that it can be passed to functions or even "
"serialized and sent across the wire."
msgstr ""

#: ../../getting-started/next-steps.rst:389
msgid ""
"You can create a subtask for the ``add`` task using the arguments ``(2, "
"2)``, and a countdown of 10 seconds like this::"
msgstr ""

#: ../../getting-started/next-steps.rst:395
msgid "There is also a shortcut using star arguments::"
msgstr ""

#: ../../getting-started/next-steps.rst:401
msgid "And there's that calling API again…"
msgstr ""

#: ../../getting-started/next-steps.rst:403
msgid ""
"Subtask instances also supports the calling API, which means that they have "
"the ``delay`` and ``apply_async`` methods."
msgstr ""

#: ../../getting-started/next-steps.rst:406
msgid ""
"But there is a difference in that the subtask may already have an argument "
"signature specified.  The ``add`` task takes two arguments, so a subtask "
"specifying two arguments would make a complete signature::"
msgstr ""

#: ../../getting-started/next-steps.rst:415
msgid ""
"But, you can also make incomplete signatures to create what we call "
"*partials*::"
msgstr ""

#: ../../getting-started/next-steps.rst:421
msgid ""
"``s2`` is now a partial subtask that needs another argument to be complete, "
"and this can be resolved when calling the subtask::"
msgstr ""

#: ../../getting-started/next-steps.rst:429
msgid ""
"Here you added the argument 8, which was prepended to the existing argument "
"2 forming a complete signature of ``add(8, 2)``."
msgstr ""

#: ../../getting-started/next-steps.rst:432
msgid ""
"Keyword arguments can also be added later, these are then merged with any "
"existing keyword arguments, but with new arguments taking precedence::"
msgstr ""

#: ../../getting-started/next-steps.rst:438
msgid "As stated subtasks supports the calling API, which means that:"
msgstr ""

#: ../../getting-started/next-steps.rst:440
msgid "``subtask.apply_async(args=(), kwargs={}, **options)``"
msgstr ""

#: ../../getting-started/next-steps.rst:442
msgid ""
"Calls the subtask with optional partial arguments and partial keyword "
"arguments.  Also supports partial execution options."
msgstr ""

#: ../../getting-started/next-steps.rst:445
msgid "``subtask.delay(*args, **kwargs)``"
msgstr ""

#: ../../getting-started/next-steps.rst:447
msgid ""
"Star argument version of ``apply_async``.  Any arguments will be prepended "
"to the arguments in the signature, and keyword arguments is merged with any "
"existing keys."
msgstr ""

#: ../../getting-started/next-steps.rst:451
msgid ""
"So this all seems very useful, but what can you actually do with these? To "
"get to that I must introduce the canvas primitives…"
msgstr ""

#: ../../getting-started/next-steps.rst:455
msgid "The Primitives"
msgstr ""

#: ../../getting-started/next-steps.rst:0
msgid "\\"
msgstr ""

#: ../../getting-started/next-steps.rst:462
msgid ":ref:`group <canvas-group>`"
msgstr ""

#: ../../getting-started/next-steps.rst:463
msgid ":ref:`chain <canvas-chain>`"
msgstr ""

#: ../../getting-started/next-steps.rst:464
msgid ":ref:`chord <canvas-chord>`"
msgstr ""

#: ../../getting-started/next-steps.rst:465
msgid ":ref:`map <canvas-map>`"
msgstr ""

#: ../../getting-started/next-steps.rst:466
msgid ":ref:`starmap <canvas-map>`"
msgstr ""

#: ../../getting-started/next-steps.rst:467
msgid ":ref:`chunks <canvas-chunks>`"
msgstr ""

#: ../../getting-started/next-steps.rst:469
msgid ""
"The primitives are subtasks themselves, so that they can be combined in any "
"number of ways to compose complex workflows."
msgstr ""

#: ../../getting-started/next-steps.rst:474
msgid ""
"These examples retrieve results, so to try them out you need to configure a "
"result backend. The example project above already does that (see the backend"
" argument to :class:`~celery.Celery`)."
msgstr ""

#: ../../getting-started/next-steps.rst:478
msgid "Let's look at some examples:"
msgstr ""

#: ../../getting-started/next-steps.rst:481
msgid "Groups"
msgstr ""

#: ../../getting-started/next-steps.rst:483
msgid ""
"A :class:`~celery.group` calls a list of tasks in parallel, and it returns a"
" special result instance that lets you inspect the results as a group, and "
"retrieve the return values in order."
msgstr ""

#: ../../getting-started/next-steps.rst:495
msgid "Partial group"
msgstr ""

#: ../../getting-started/next-steps.rst:504
msgid "Chains"
msgstr ""

#: ../../getting-started/next-steps.rst:506
msgid ""
"Tasks can be linked together so that after one task returns the other is "
"called:"
msgstr ""

#: ../../getting-started/next-steps.rst:519
msgid "or a partial chain:"
msgstr ""

#: ../../getting-started/next-steps.rst:529
msgid "Chains can also be written like this:"
msgstr ""

#: ../../getting-started/next-steps.rst:537
msgid "Chords"
msgstr ""

#: ../../getting-started/next-steps.rst:539
msgid "A chord is a group with a callback:"
msgstr ""

#: ../../getting-started/next-steps.rst:550
msgid ""
"A group chained to another task will be automatically converted to a chord:"
msgstr ""

#: ../../getting-started/next-steps.rst:559
msgid ""
"Since these primitives are all of the subtask type they can be combined "
"almost however you want, e.g::"
msgstr ""

#: ../../getting-started/next-steps.rst:564
msgid ""
"Be sure to read more about workflows in the :ref:`Canvas <guide-canvas>` "
"user guide."
msgstr ""

#: ../../getting-started/next-steps.rst:568
msgid "Routing"
msgstr ""

#: ../../getting-started/next-steps.rst:570
msgid ""
"Celery supports all of the routing facilities provided by AMQP, but it also "
"supports simple routing where messages are sent to named queues."
msgstr ""

#: ../../getting-started/next-steps.rst:573
msgid ""
"The :setting:`CELERY_ROUTES` setting enables you to route tasks by name and "
"keep everything centralized in one location::"
msgstr ""

#: ../../getting-started/next-steps.rst:582
msgid ""
"You can also specify the queue at runtime with the ``queue`` argument to "
"``apply_async``::"
msgstr ""

#: ../../getting-started/next-steps.rst:588
msgid ""
"You can then make a worker consume from this queue by specifying the "
":option:`-Q` option:"
msgstr ""

#: ../../getting-started/next-steps.rst:595
msgid ""
"You may specify multiple queues by using a comma separated list, for example"
" you can make the worker consume from both the default queue, and the "
"``hipri`` queue, where the default queue is named ``celery`` for historical "
"reasons:"
msgstr ""

#: ../../getting-started/next-steps.rst:604
msgid ""
"The order of the queues doesn't matter as the worker will give equal weight "
"to the queues."
msgstr ""

#: ../../getting-started/next-steps.rst:607
msgid ""
"To learn more about routing, including taking use of the full power of AMQP "
"routing, see the :ref:`Routing Guide <guide-routing>`."
msgstr ""

#: ../../getting-started/next-steps.rst:611
msgid "Remote Control"
msgstr ""

#: ../../getting-started/next-steps.rst:613
msgid ""
"If you're using RabbitMQ (AMQP), Redis or MongoDB as the broker then you can"
" control and inspect the worker at runtime."
msgstr ""

#: ../../getting-started/next-steps.rst:616
msgid "For example you can see what tasks the worker is currently working on:"
msgstr ""

#: ../../getting-started/next-steps.rst:622
msgid ""
"This is implemented by using broadcast messaging, so all remote control "
"commands are received by every worker in the cluster."
msgstr ""

#: ../../getting-started/next-steps.rst:625
msgid ""
"You can also specify one or more workers to act on the request using the "
":option:`--destination` option, which is a comma separated list of worker "
"host names:"
msgstr ""

#: ../../getting-started/next-steps.rst:633
msgid ""
"If a destination is not provided then every worker will act and reply to the"
" request."
msgstr ""

#: ../../getting-started/next-steps.rst:636
msgid ""
"The :program:`celery inspect` command contains commands that does not change"
" anything in the worker, it only replies information and statistics about "
"what is going on inside the worker. For a list of inspect commands you can "
"execute:"
msgstr ""

#: ../../getting-started/next-steps.rst:645
msgid ""
"Then there is the :program:`celery control` command, which contains commands"
" that actually changes things in the worker at runtime:"
msgstr ""

#: ../../getting-started/next-steps.rst:652
msgid ""
"For example you can force workers to enable event messages (used for "
"monitoring tasks and workers):"
msgstr ""

#: ../../getting-started/next-steps.rst:659
msgid ""
"When events are enabled you can then start the event dumper to see what the "
"workers are doing:"
msgstr ""

#: ../../getting-started/next-steps.rst:666
msgid "or you can start the curses interface:"
msgstr ""

#: ../../getting-started/next-steps.rst:672
msgid "when you're finished monitoring you can disable events again:"
msgstr ""

#: ../../getting-started/next-steps.rst:678
msgid ""
"The :program:`celery status` command also uses remote control commands and "
"shows a list of online workers in the cluster:"
msgstr ""

#: ../../getting-started/next-steps.rst:685
msgid ""
"You can read more about the :program:`celery` command and monitoring in the "
":ref:`Monitoring Guide <guide-monitoring>`."
msgstr ""

#: ../../getting-started/next-steps.rst:689
msgid "Timezone"
msgstr ""

#: ../../getting-started/next-steps.rst:691
msgid "All times and dates, internally and in messages uses the UTC timezone."
msgstr ""

#: ../../getting-started/next-steps.rst:693
msgid ""
"When the worker receives a message, for example with a countdown set it "
"converts that UTC time to local time.  If you wish to use a different "
"timezone than the system timezone then you must configure that using the "
":setting:`CELERY_TIMEZONE` setting::"
msgstr ""

#: ../../getting-started/next-steps.rst:701
msgid "Optimization"
msgstr ""

#: ../../getting-started/next-steps.rst:703
msgid ""
"The default configuration is not optimized for throughput by default, it "
"tries to walk the middle way between many short tasks and fewer long tasks, "
"a compromise between throughput and fair scheduling."
msgstr ""

#: ../../getting-started/next-steps.rst:707
msgid ""
"If you have strict fair scheduling requirements, or want to optimize for "
"throughput then you should read the :ref:`Optimizing Guide <guide-"
"optimizing>`."
msgstr ""

#: ../../getting-started/next-steps.rst:711
msgid ""
"If you're using RabbitMQ then you should install the :mod:`librabbitmq` "
"module, which is an AMQP client implemented in C:"
msgstr ""

#: ../../getting-started/next-steps.rst:719
msgid "What to do now?"
msgstr ""

#: ../../getting-started/next-steps.rst:721
msgid ""
"Now that you have read this document you should continue to the :ref:`User "
"Guide <guide>`."
msgstr ""

#: ../../getting-started/next-steps.rst:724
msgid "There's also an :ref:`API reference <apiref>` if you are so inclined."
msgstr ""
