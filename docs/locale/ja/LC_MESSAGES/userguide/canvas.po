#
msgid ""
msgstr ""
"Project-Id-Version: Celery 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-10 16:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../userguide/canvas.rst:5
msgid "Canvas: Designing Workflows"
msgstr "Canvas: ワークフローの設計"

#: ../../userguide/canvas.rst:16
msgid "Signatures"
msgstr "シグニチャ"

#: ../../userguide/canvas.rst:20
msgid ""
"You just learned how to call a task using the tasks ``delay`` method in the "
":ref:`calling <guide-calling>` guide, and this is often all you need, but "
"sometimes you may want to pass the signature of a task invocation to another"
" process or as an argument to another function."
msgstr ""
":ref:`タスクコール <guide-calling>` で ``delay`` メソッドを使ってタスクを呼び出す方法を学びました。"
"大半のケースではこれだけで事足りますが、タスク実行のシグニチャを別のプロセス、または別の関数の引数として渡したい"
"といったケースが出てくることもあります。"

#: ../../userguide/canvas.rst:25
msgid ""
"A :func:`~celery.signature` wraps the arguments, keyword arguments, and "
"execution options of a single task invocation in a way such that it can be "
"passed to functions or even serialized and sent across the wire."
msgstr ""
":func:`~celery.signature` 関数は、引数とキーワード引数、そして単一タスクの実行オプションをラップし、"
"他の関数に渡したり、シリアライズしてネットワーク越しに送ったりできるようにします。"

#: ../../userguide/canvas.rst:29
msgid ""
"Signatures are often nicknamed \"subtasks\" because they describe a task to "
"be called within a task."
msgstr ""
"シグニチャはタスク内から呼ばれるタスクに当たるものなので、しばしば「サブタスク」と称されます。"

#: ../../userguide/canvas.rst:32
msgid ""
"You can create a signature for the ``add`` task using its name like this::"
msgstr ""
"``add`` タスクのシグニチャはその名前を使って次のように作成されます:"


#: ../../userguide/canvas.rst:38
msgid ""
"This task has a signature of arity 2 (two arguments): ``(2, 2)``, and sets "
"the countdown execution option to 10."
msgstr ""
"このタスクは二つの引数 ``(2, 2)`` のシグニチャを持ち、countdown 実行オプションには 10 がセットされています。"

#: ../../userguide/canvas.rst:41
msgid "or you can create one using the task's ``subtask`` method::"
msgstr ""
"また、タスクの ``subtask`` メソッドを使って作成することも可能です:"

#: ../../userguide/canvas.rst:46
msgid "There is also a shortcut using star arguments::"
msgstr "star arguments を使うショートカットメソッドもあります:"

#: ../../userguide/canvas.rst:51
msgid "Keyword arguments are also supported::"
msgstr "キーワード引数もサポートされています:"

#: ../../userguide/canvas.rst:56
msgid "From any signature instance you can inspect the different fields::"
msgstr "シグニチャのインスタンスから様々な情報を抜き出すことができます:"

#: ../../userguide/canvas.rst:66
msgid ""
"It supports the \"Calling API\" which means it supports ``delay`` and "
"``apply_async`` or being called directly."
msgstr "\"Calling API\" もサポートしています。"
"これはつまり ``dalay`` や ``apply_async`` メソッド、直接の実行をサポートしているということです。"

#: ../../userguide/canvas.rst:69
msgid ""
"Calling the signature will execute the task inline in the current process::"
msgstr ""
"シグニチャインスタンスを呼び出すと、カレントプロセスでタスクを実行します:"

#: ../../userguide/canvas.rst:76
msgid ""
"``delay`` is our beloved shortcut to ``apply_async`` taking star-arguments::"
msgstr "``dalay`` は ``apply_async`` のショートカットで star-arguments を取ります:"

#: ../../userguide/canvas.rst:82
msgid ""
"``apply_async`` takes the same arguments as the :meth:`Task.apply_async "
"<@Task.apply_async>` method::"
msgstr ""
"``apply_async`` は :meth:`Task.apply_async <@Task.apply_async>` メソッドと同じ引数を取ります:"

#: ../../userguide/canvas.rst:90
msgid ""
"You can't define options with :meth:`~@Task.s`, but a chaining ``set`` call "
"takes care of that::"
msgstr ""
":meth:`~@Task.s` メソッドでは実行オプションを指定できませんが、それに続く ``set`` メソッドで対応できます:"

#: ../../userguide/canvas.rst:97
msgid "Partials"
msgstr ""

#: ../../userguide/canvas.rst:99
msgid "With a signature, you can execute the task in a worker::"
msgstr "ワーカーでシグニチャのタスクを実行できます:"

#: ../../userguide/canvas.rst:104
msgid "Or you can call it directly in the current process::"
msgstr "またカレントプロセスで直接実行することもできます:"

#: ../../userguide/canvas.rst:109
msgid ""
"Specifying additional args, kwargs or options to ``apply_async``/``delay`` "
"creates partials:"
msgstr "``apply_async``/``delay`` に追加の引数、キーワード引数、実行オプションを指定すると、"
"partial を生成します:"

#: ../../userguide/canvas.rst:112
msgid "Any arguments added will be prepended to the args in the signature::"
msgstr "追加引数は、シグニチャに定義された引数の前に与えられます:"

#: ../../userguide/canvas.rst:118
msgid ""
"Any keyword arguments added will be merged with the kwargs in the signature,"
" with the new keyword arguments taking precedence::"
msgstr ""
"キーワード引数はシグニチャで指定されたものにマージされます。新しいキーワード引数が優先されます:"

#: ../../userguide/canvas.rst:125
msgid ""
"Any options added will be merged with the options in the signature, with the"
" new options taking precedence::"
msgstr ""
"オプションはシグニチャで指定されたオプションにマージされます。新しいオプションが優先されます:"

#: ../../userguide/canvas.rst:131
msgid "You can also clone signatures to create derivates:"
msgstr "あるシグニチャから派生したシグニチャを作成するためにクローンすることも可能です:"

#: ../../userguide/canvas.rst:140
msgid "Immutability"
msgstr "不変性"

#: ../../userguide/canvas.rst:144
msgid ""
"Partials are meant to be used with callbacks, any tasks linked or chord "
"callbacks will be applied with the result of the parent task. Sometimes you "
"want to specify a callback that does not take additional arguments, and in "
"that case you can set the signature to be immutable::"
msgstr ""
"Partials はコールバックで使われるためのもので、リンクされたタスクやコールバックは親タスクの結果と共に呼ばれます。"
"追加の引数を取らないコールバックを指定する時には、シグニチャが不変だとセットできます:"

#: ../../userguide/canvas.rst:152
msgid ""
"The ``.si()`` shortcut can also be used to create immutable signatures::"
msgstr ""
"``.si()`` もまた不変シグニチャを生成するショートカットです:"

#: ../../userguide/canvas.rst:156
msgid ""
"Only the execution options can be set when a signature is immutable, so it's"
" not possible to call the signature with partial args/kwargs."
msgstr ""
"シグニチャが不変な場合、実行オプションのみセット可能です。"
"部分引数/キーワード引数を付けてシグニチャを呼ぶことはできません。"

#: ../../userguide/canvas.rst:161
msgid ""
"In this tutorial I sometimes use the prefix operator `~` to signatures. You "
"probably shouldn't use it in your production code, but it's a handy shortcut"
" when experimenting in the Python shell::"
msgstr ""

#: ../../userguide/canvas.rst:174
msgid "Callbacks"
msgstr "コールバック"

#: ../../userguide/canvas.rst:178
msgid ""
"Callbacks can be added to any task using the ``link`` argument to "
"``apply_async``::"
msgstr ""
"コールバックは ``apply_async`` の ``link`` 引数に指定してタスクに追加します:"

#: ../../userguide/canvas.rst:183
msgid ""
"The callback will only be applied if the task exited successfully, and it "
"will be applied with the return value of the parent task as argument."
msgstr ""
"コールバックはタスクの実行に成功した場合にのみ呼ばれ、"
"親タスクの戻り値が引数に渡されます。"

#: ../../userguide/canvas.rst:186
msgid ""
"As I mentioned earlier, any arguments you add to a signature, will be "
"prepended to the arguments specified by the signature itself!"
msgstr ""
"前述のようにシグニチャに追加した引数は、シグニチャ自身で指定された引数の前に追加されます。"

#: ../../userguide/canvas.rst:189
msgid "If you have the signature::"
msgstr "このようなシグニチャの場合:"

#: ../../userguide/canvas.rst:193
msgid "then `sig.delay(result)` becomes::"
msgstr "`sig.delay(result)` はこうなります:"

#: ../../userguide/canvas.rst:197
msgid "..."
msgstr ""

#: ../../userguide/canvas.rst:199
msgid ""
"Now let's call our ``add`` task with a callback using partial arguments::"
msgstr ""
"部分引数を使って ``add`` タスクのコールバックを呼んでみましょう:"

#: ../../userguide/canvas.rst:204
msgid ""
"As expected this will first launch one task calculating :math:`2 + 2`, then "
"another task calculating :math:`4 + 8`."
msgstr ""
"期待通り、最初のタスクが :math:`2 + 2` を計算し、"
"次に別のタスクが :math:`4 + 8` を計算しています。"

#: ../../userguide/canvas.rst:208
msgid "The Primitives"
msgstr "プリミティブ"

#: ../../userguide/canvas.rst:0
msgid "Overview"
msgstr "概要"

#: ../../userguide/canvas.rst:214
msgid "``group``"
msgstr ""

#: ../../userguide/canvas.rst:216
msgid ""
"The group primitive is a signature that takes a list of tasks that should be"
" applied in parallel."
msgstr ""
"group プリミティブは並列に実行されるタスクのリストからなるシグニチャです。"

#: ../../userguide/canvas.rst:219
msgid "``chain``"
msgstr ""

#: ../../userguide/canvas.rst:221
msgid ""
"The chain primitive lets us link together signatures so that one is called "
"after the other, essentially forming a *chain* of callbacks."
msgstr ""
"chain プリミティブは、あるシグニチャが呼ばれた後に次のシグニチャが呼ばれるように複数のシグニチャを連結します。"
"これはコールバック *チェーン* を作成するのに有用です。"

#: ../../userguide/canvas.rst:224
msgid "``chord``"
msgstr ""

#: ../../userguide/canvas.rst:226
msgid ""
"A chord is just like a group but with a callback.  A chord consists of a "
"header group and a body,  where the body is a task that should execute after"
" all of the tasks in the header are complete."
msgstr ""
"chord はコールバックを備えるグループです。"
"ヘッダーグループと本体から構成され、本体はヘッダーの全タスク完了後に実行されるタスクです。"

#: ../../userguide/canvas.rst:230
msgid "``map``"
msgstr ""

#: ../../userguide/canvas.rst:232
msgid ""
"The map primitive works like the built-in ``map`` function, but creates a "
"temporary task where a list of arguments is applied to the task. E.g. "
"``task.map([1, 2])`` results in a single task being called, applying the "
"arguments in order to the task function so that the result is::"
msgstr ""
"map プリミティブは組み込みの ``map`` 関数と同様の機能ですが、"
"引数のリスト要素をタスクに渡してコールする一時的なタスクを生成します。"
"例えば ``task.map([1, 2])`` は単一のタスクを生成し、指定された引数は順にタスク関数に渡され、"
"最終的には以下のようになります:"

#: ../../userguide/canvas.rst:240
msgid "``starmap``"
msgstr ""

#: ../../userguide/canvas.rst:242
msgid ""
"Works exactly like map except the arguments are applied as ``*args``. For "
"example ``add.starmap([(2, 2), (4, 4)])`` results in a single task calling::"
msgstr ""
"引数が ``*args`` として渡される以外は map と全く同じです。"
"例えば ``add.starmap([(2, 2), (4, 4)])`` は以下の単一タスクになります::"

#: ../../userguide/canvas.rst:248
msgid "``chunks``"
msgstr ""

#: ../../userguide/canvas.rst:250
msgid ""
"Chunking splits a long list of arguments into parts, e.g the operation::"
msgstr ""
"chunks は長い引数リストを分割します:"

#: ../../userguide/canvas.rst:255
msgid ""
"will split the list of items into chunks of 10, resulting in 100 tasks (each"
" processing 10 items in sequence)."
msgstr ""
"この例はアイテムのリストを 10個 ずつに分割し、100 個のタスクを生成します"
"(それぞれのタスクが 10 アイテムを順に処理します)。"

#: ../../userguide/canvas.rst:259
msgid ""
"The primitives are also signature objects themselves, so that they can be "
"combined in any number of ways to compose complex workflows."
msgstr "プリミティブ自身もシグニチャオブジェクトなので、"
"それらを組み合わせて複雑なワークフローを構成できます。"

#: ../../userguide/canvas.rst:262
msgid "Here's some examples:"
msgstr "いくつか例を紹介します:"

#: ../../userguide/canvas.rst:264
msgid "Simple chain"
msgstr "シンプルな chain"

#: ../../userguide/canvas.rst:266
msgid ""
"Here's a simple chain, the first task executes passing its return value to "
"the next task in the chain, and so on."
msgstr "シンプルな chain の例です。最初のタスクの戻り値が chain の後続タスクに渡さます。"

#: ../../userguide/canvas.rst:278
msgid "This can also be written using pipes::"
msgstr "これは次のようにパイプを使って書くこともできます:"

#: ../../userguide/canvas.rst:283
msgid "Immutable signatures"
msgstr "不変シグニチャ"

#: ../../userguide/canvas.rst:285
msgid ""
"Signatures can be partial so arguments can be added to the existing "
"arguments, but you may not always want that, for example if you don't want "
"the result of the previous task in a chain."
msgstr ""

#: ../../userguide/canvas.rst:289
msgid ""
"In that case you can mark the signature as immutable, so that the arguments "
"cannot be changed::"
msgstr ""

#: ../../userguide/canvas.rst:294
msgid "There's also an ``.si`` shortcut for this::"
msgstr ""

#: ../../userguide/canvas.rst:298
msgid "Now you can create a chain of independent tasks instead::"
msgstr ""

#: ../../userguide/canvas.rst:310
msgid "Simple group"
msgstr "シンプルな group"

#: ../../userguide/canvas.rst:312
msgid "You can easily create a group of tasks to execute in parallel::"
msgstr "並列に実行されるタスクの group を簡単に作成できます:"

#: ../../userguide/canvas.rst:319
msgid "Simple chord"
msgstr ""

#: ../../userguide/canvas.rst:321
msgid ""
"The chord primitive enables us to add callback to be called when all of the "
"tasks in a group have finished executing, which is often required for "
"algorithms that aren't embarrassingly parallel::"
msgstr ""

#: ../../userguide/canvas.rst:330
msgid ""
"The above example creates 10 task that all start in parallel, and when all "
"of them are complete the return values are combined into a list and sent to "
"the ``xsum`` task."
msgstr ""

#: ../../userguide/canvas.rst:334
msgid ""
"The body of a chord can also be immutable, so that the return value of the "
"group is not passed on to the callback::"
msgstr ""

#: ../../userguide/canvas.rst:340
msgid "Note the use of ``.si`` above which creates an immutable signature."
msgstr ""

#: ../../userguide/canvas.rst:342
msgid "Blow your mind by combining"
msgstr ""

#: ../../userguide/canvas.rst:344
msgid "Chains can be partial too::"
msgstr ""

#: ../../userguide/canvas.rst:353
msgid "Which means that you can combine chains::"
msgstr ""

#: ../../userguide/canvas.rst:362
msgid ""
"Chaining a group together with another task will automatically upgrade it to"
" be a chord::"
msgstr ""

#: ../../userguide/canvas.rst:370
msgid ""
"Groups and chords accepts partial arguments too, so in a chain the return "
"value of the previous task is forwarded to all tasks in the group::"
msgstr ""

#: ../../userguide/canvas.rst:383
msgid ""
"If you don't want to forward arguments to the group then you can make the "
"signatures in the group immutable::"
msgstr ""

#: ../../userguide/canvas.rst:407
msgid "Chains"
msgstr ""

#: ../../userguide/canvas.rst:411
msgid ""
"Tasks can be linked together, which in practice means adding a callback "
"task::"
msgstr ""

#: ../../userguide/canvas.rst:418
msgid ""
"The linked task will be applied with the result of its parent task as the "
"first argument, which in the above case will result in ``mul(4, 16)`` since "
"the result is 4."
msgstr ""

#: ../../userguide/canvas.rst:505
msgid ""
"The result instance also has a :meth:`~@AsyncResult.collect` method that "
"treats the result as a graph, enabling you to iterate over the results::"
msgstr ""

#: ../../userguide/canvas.rst:513
msgid ""
"By default :meth:`~@AsyncResult.collect` will raise an "
":exc:`~@IncompleteStream` exception if the graph is not fully formed (one of"
" the tasks has not completed yet), but you can get an intermediate "
"representation of the graph too::"
msgstr ""

#: ../../userguide/canvas.rst:422
msgid "You can also add *error callbacks* using the ``link_error`` argument::"
msgstr ""

#: ../../userguide/canvas.rst:428
msgid ""
"Since exceptions can only be serialized when pickle is used the error "
"callbacks take the id of the parent task as argument instead:"
msgstr ""

#: ../../userguide/canvas.rst:445
msgid ""
"To make it even easier to link tasks together there is a special signature "
"called :class:`~celery.chain` that lets you chain tasks together:"
msgstr ""

#: ../../userguide/canvas.rst:459
msgid ""
"Calling the chain will call the tasks in the current process and return the "
"result of the last task in the chain::"
msgstr ""

#: ../../userguide/canvas.rst:466
msgid ""
"It also sets ``parent`` attributes so that you can work your way up the "
"chain to get intermediate results::"
msgstr ""

#: ../../userguide/canvas.rst:478
msgid "Chains can also be made using the ``|`` (pipe) operator::"
msgstr ""

#: ../../userguide/canvas.rst:524
msgid "Graphs"
msgstr ""

#: ../../userguide/canvas.rst:526
msgid ""
"In addition you can work with the result graph as a "
":class:`~celery.datastructures.DependencyGraph`:"
msgstr ""

#: ../../userguide/canvas.rst:540
msgid "You can even convert these graphs to *dot* format::"
msgstr ""

#: ../../userguide/canvas.rst:546
msgid "and create images:"
msgstr ""

#: ../../userguide/canvas.rst:557
msgid "Groups"
msgstr ""

#: ../../userguide/canvas.rst:561
msgid "A group can be used to execute several tasks in parallel."
msgstr ""

#: ../../userguide/canvas.rst:563
msgid "The :class:`~celery.group` function takes a list of signatures::"
msgstr ""

#: ../../userguide/canvas.rst:571
msgid ""
"If you **call** the group, the tasks will be applied one after one in the "
"current process, and a :class:`~celery.result.GroupResult` instance is "
"returned which can be used to keep track of the results, or tell how many "
"tasks are ready and so on::"
msgstr ""

#: ../../userguide/canvas.rst:581
msgid "Group also supports iterators::"
msgstr ""

#: ../../userguide/canvas.rst:585
msgid ""
"A group is a signature object, so it can be used in combination with other "
"signatures."
msgstr ""

#: ../../userguide/canvas.rst:589
msgid "Group Results"
msgstr ""

#: ../../userguide/canvas.rst:591
msgid ""
"The group task returns a special result too, this result works just like "
"normal task results, except that it works on the group as a whole::"
msgstr ""

#: ../../userguide/canvas.rst:615
msgid ""
"The :class:`~celery.result.GroupResult` takes a list of "
":class:`~celery.result.AsyncResult` instances and operates on them as if it "
"was a single task."
msgstr ""

#: ../../userguide/canvas.rst:619
msgid "It supports the following operations:"
msgstr ""

#: ../../userguide/canvas.rst:621
msgid ":meth:`~celery.result.GroupResult.successful`"
msgstr ""

#: ../../userguide/canvas.rst:623
msgid ""
"Return :const:`True` if all of the subtasks finished successfully (e.g. did "
"not raise an exception)."
msgstr ""

#: ../../userguide/canvas.rst:626
msgid ":meth:`~celery.result.GroupResult.failed`"
msgstr ""

#: ../../userguide/canvas.rst:628
msgid "Return :const:`True` if any of the subtasks failed."
msgstr ""

#: ../../userguide/canvas.rst:630
msgid ":meth:`~celery.result.GroupResult.waiting`"
msgstr ""

#: ../../userguide/canvas.rst:632
msgid "Return :const:`True` if any of the subtasks is not ready yet."
msgstr ""

#: ../../userguide/canvas.rst:635
msgid ":meth:`~celery.result.GroupResult.ready`"
msgstr ""

#: ../../userguide/canvas.rst:637
msgid "Return :const:`True` if all of the subtasks are ready."
msgstr ""

#: ../../userguide/canvas.rst:640
msgid ":meth:`~celery.result.GroupResult.completed_count`"
msgstr ""

#: ../../userguide/canvas.rst:642
msgid "Return the number of completed subtasks."
msgstr ""

#: ../../userguide/canvas.rst:644
msgid ":meth:`~celery.result.GroupResult.revoke`"
msgstr ""

#: ../../userguide/canvas.rst:646
msgid "Revoke all of the subtasks."
msgstr ""

#: ../../userguide/canvas.rst:648
msgid ":meth:`~celery.result.GroupResult.join`"
msgstr ""

#: ../../userguide/canvas.rst:650
msgid ""
"Gather the results for all of the subtasks and return a list with them "
"ordered by the order of which they were called."
msgstr ""

#: ../../userguide/canvas.rst:657
msgid "Chords"
msgstr ""

#: ../../userguide/canvas.rst:663
msgid ""
"Tasks used within a chord must *not* ignore their results. If the result "
"backend is disabled for *any* task (header or body) in your chord you should"
" read \":ref:`chord-important-notes`\"."
msgstr ""

#: ../../userguide/canvas.rst:668
msgid ""
"A chord is a task that only executes after all of the tasks in a group have "
"finished executing."
msgstr ""
"Chorid はグループの全タスクの実行完了後にのみ実行されるタスクです。"

#: ../../userguide/canvas.rst:672
msgid ""
"Let's calculate the sum of the expression :math:`1 + 1 + 2 + 2 + 3 + 3 ... n"
" + n` up to a hundred digits."
msgstr ""
":math:`1 + 1 + 2 + 2 + 3 + 3 ... n + n` と 100 まで続く足し算を行ってみましょう。"

#: ../../userguide/canvas.rst:675
msgid ""
"First you need two tasks, :func:`add` and :func:`tsum` (:func:`sum` is "
"already a standard function):"
msgstr ""
"まず二つのタスクが必要です。:func:`add` と :func:`tsum` (:func:`sum` は標準関数でありますね)です:"

#: ../../userguide/canvas.rst:689
msgid ""
"Now you can use a chord to calculate each addition step in parallel, and "
"then get the sum of the resulting numbers::"
msgstr ""
"そして、Chord を使ってそれぞれの数字の足し算を並列に計算し、それらの結果の数値の和を求めます::"

#: ../../userguide/canvas.rst:700
msgid ""
"This is obviously a very contrived example, the overhead of messaging and "
"synchronization makes this a lot slower than its Python counterpart::"
msgstr ""
"これは明らかに不自然な実行例なので、メッセージングや同期処理のオーバーヘッドのために次のように Python で"
"直に計算するよりかなり遅くなります::"

#: ../../userguide/canvas.rst:705
msgid ""
"The synchronization step is costly, so you should avoid using chords as much"
" as possible. Still, the chord is a powerful primitive to have in your "
"toolbox as synchronization is a required step for many parallel algorithms."
msgstr ""
"同期処理部分はコストが掛かるので、可能な限り Chord を使うのは避けるべきです。"
"それでも、たくさんの並列処理の後に同期処理が必要な場合には Chord はとても役に立つ Pirimitive なので"
"知っておいて損はありません。。"

#: ../../userguide/canvas.rst:709
msgid "Let's break the chord expression down:"
msgstr "Chord の式を小分けに見てみましょう:"

#: ../../userguide/canvas.rst:719
msgid ""
"Remember, the callback can only be executed after all of the tasks in the "
"header have returned.  Each step in the header is executed as a task, in "
"parallel, possibly on different nodes.  The callback is then applied with "
"the return value of each task in the header.  The task id returned by "
":meth:`chord` is the id of the callback, so you can wait for it to complete "
"and get the final return value (but remember to :ref:`never have a task wait"
" for other tasks <task-synchronous-subtasks>`)"
msgstr ""
"コールバックは header のすべてのタスクがリターンした後に実行されることを忘れないでください。"
"header のそれぞれのステップは一つのタスクとして、並列に、場合によっては異なるノードで実行されます。"
"コールバックは header の各タスクの結果と共に呼び出されます。 "
":meth:`chord` が返すタスク ID はコールバックの ID なので、実行が完了するのを待ち、最終的な結果を取得することができます"
"(但し、 :ref:`never have a task wait for other tasks <task-synchronous-subtasks>` にも注意してください)。"

#: ../../userguide/canvas.rst:730
msgid "Error handling"
msgstr "エラーの取り扱い"

#: ../../userguide/canvas.rst:732
msgid "So what happens if one of the tasks raises an exception?"
msgstr "もしタスクの一つが例外を送出した場合どうなるか？"

#: ../../userguide/canvas.rst:734
msgid ""
"This was not documented for some time and before version 3.1 the exception "
"value will be forwarded to the chord callback."
msgstr ""
"このことについてはドキュメント化されておらず、3.1 より前のバージョンではこのような例外の値は Chord のコールバックに転送されます。"

#: ../../userguide/canvas.rst:738
msgid ""
"From 3.1 errors will propagate to the callback, so the callback will not be "
"executed instead the callback changes to failure state, and the error is set"
" to the :exc:`~@ChordError` exception:"
msgstr ""
"3.1 からは、エラーはコールバックまで伝播して、コールバックは実行されずに失敗ステートに変化し、"
"エラーは :exc:`~@ChordError` にセットされます:"

#: ../../userguide/canvas.rst:756
msgid ""
"If you're running 3.0.14 or later you can enable the new behavior via the "
":setting:`CELERY_CHORD_PROPAGATES` setting::"
msgstr "3.0.14 以降で :setting:`CELERY_CHORD_PROPAGATES` 設定でこの新しい挙動を有効化できます:"

#: ../../userguide/canvas.rst:761
msgid ""
"While the traceback may be different depending on which result backend is "
"being used, you can see the error description includes the id of the task "
"that failed and a string representation of the original exception.  You can "
"also find the original traceback in ``result.traceback``."
msgstr ""
"トレースバックは結果バックエンドによって異なりますが、失敗したタスクの ID を含むエラー記述と"
"オリジナルの例外の文字列表現は確認できます。"
"また ``result.traceback`` でオリジナルのトレースバックも取得できます。"

#: ../../userguide/canvas.rst:766
msgid ""
"Note that the rest of the tasks will still execute, so the third task "
"(``add.s(8, 8)``) is still executed even though the middle task failed. Also"
" the :exc:`~@ChordError` only shows the task that failed first (in time): it"
" does not respect the ordering of the header group."
msgstr ""
"例外が送出されても残りのタスクは実行されることに注意してください。つまり、3番目のタスク(``add.s(8, 8)``)は、"
"真ん中のタスクが失敗しても実行されます。"
"また、 :exc:`~@ChordError` に含まれるタスクは(時間的に)最初に失敗したタスクのものになります。"
"header グループのリストの順番は関係ありません。"

#: ../../userguide/canvas.rst:774
msgid "Important Notes"
msgstr ""

#: ../../userguide/canvas.rst:776
msgid ""
"Tasks used within a chord must *not* ignore their results. In practice this "
"means that you must enable a :const:`CELERY_RESULT_BACKEND` in order to use "
"chords. Additionally, if :const:`CELERY_IGNORE_RESULT` is set to "
":const:`True` in your configuration, be sure that the individual tasks to be"
" used within the chord are defined with :const:`ignore_result=False`. This "
"applies to both Task subclasses and decorated tasks."
msgstr ""

#: ../../userguide/canvas.rst:783
msgid "Example Task subclass:"
msgstr ""

#: ../../userguide/canvas.rst:792
msgid "Example decorated task:"
msgstr ""

#: ../../userguide/canvas.rst:800
msgid ""
"By default the synchronization step is implemented by having a recurring "
"task poll the completion of the group every second, calling the signature "
"when ready."
msgstr ""

#: ../../userguide/canvas.rst:804
msgid "Example implementation:"
msgstr ""

#: ../../userguide/canvas.rst:817
msgid ""
"This is used by all result backends except Redis and Memcached, which "
"increment a counter after each task in the header, then applying the "
"callback when the counter exceeds the number of tasks in the set. *Note:* "
"chords do not properly work with Redis before version 2.2; you will need to "
"upgrade to at least 2.2 to use them."
msgstr ""

#: ../../userguide/canvas.rst:823
msgid ""
"The Redis and Memcached approach is a much better solution, but not easily "
"implemented in other backends (suggestions welcome!)."
msgstr ""

#: ../../userguide/canvas.rst:829
msgid ""
"If you are using chords with the Redis result backend and also overriding "
"the :meth:`Task.after_return` method, you need to make sure to call the "
"super method or else the chord callback will not be applied."
msgstr ""

#: ../../userguide/canvas.rst:842
msgid "Map & Starmap"
msgstr ""

#: ../../userguide/canvas.rst:844
msgid ""
":class:`~celery.map` and :class:`~celery.starmap` are built-in tasks that "
"calls the task for every element in a sequence."
msgstr ""

#: ../../userguide/canvas.rst:847
msgid "They differ from group in that"
msgstr ""

#: ../../userguide/canvas.rst:849
msgid "only one task message is sent"
msgstr ""

#: ../../userguide/canvas.rst:851
msgid "the operation is sequential."
msgstr ""

#: ../../userguide/canvas.rst:853
msgid "For example using ``map``:"
msgstr ""

#: ../../userguide/canvas.rst:862 ../../userguide/canvas.rst:875
msgid "is the same as having a task doing:"
msgstr ""

#: ../../userguide/canvas.rst:870
msgid "and using ``starmap``::"
msgstr ""

#: ../../userguide/canvas.rst:883
msgid ""
"Both ``map`` and ``starmap`` are signature objects, so they can be used as "
"other signatures and combined in groups etc., for example to call the "
"starmap after 10 seconds::"
msgstr ""

#: ../../userguide/canvas.rst:892
msgid "Chunks"
msgstr ""

#: ../../userguide/canvas.rst:894
msgid ""
"Chunking lets you divide an iterable of work into pieces, so that if you "
"have one million objects, you can create 10 tasks with hundred thousand "
"objects each."
msgstr ""

#: ../../userguide/canvas.rst:898
msgid ""
"Some may worry that chunking your tasks results in a degradation of "
"parallelism, but this is rarely true for a busy cluster and in practice "
"since you are avoiding the overhead  of messaging it may considerably "
"increase performance."
msgstr ""

#: ../../userguide/canvas.rst:903
msgid "To create a chunks signature you can use :meth:`@Task.chunks`:"
msgstr ""

#: ../../userguide/canvas.rst:909
msgid ""
"As with :class:`~celery.group` the act of sending the messages for the "
"chunks will happen in the current process when called:"
msgstr ""

#: ../../userguide/canvas.rst:929
msgid ""
"while calling ``.apply_async`` will create a dedicated task so that the "
"individual tasks are applied in a worker instead::"
msgstr ""

#: ../../userguide/canvas.rst:935
msgid "You can also convert chunks to a group::"
msgstr ""

#: ../../userguide/canvas.rst:939
msgid ""
"and with the group skew the countdown of each task by increments of one::"
msgstr ""

#: ../../userguide/canvas.rst:944
msgid ""
"which means that the first task will have a countdown of 1, the second a "
"countdown of 2 and so on."
msgstr ""

#: ../../userguide/canvas.rst:484
msgid ""
"It's not possible to synchronize on groups, so a group chained to another "
"signature is automatically upgraded to a chord:"
msgstr ""

#: ../../userguide/canvas.rst:493
msgid "Trails"
msgstr ""

#: ../../userguide/canvas.rst:495
msgid ""
"Tasks will keep track of what subtasks a task calls in the result backend "
"(unless disabled using :attr:`Task.trail <~@Task.trail>`) and this can be "
"accessed from the result instance::"
msgstr ""

#~ msgid ""
#~ "The results will keep track of what subtasks a task applies, and this can be"
#~ " accessed from the result instance::"
#~ msgstr ""

#~ msgid ""
#~ "You can link together as many tasks as you like, and signatures can be "
#~ "linked too::"
#~ msgstr ""
