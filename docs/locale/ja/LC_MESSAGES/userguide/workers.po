#
msgid ""
msgstr ""
"Project-Id-Version: Celery 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-10 16:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../userguide/workers.rst:5
msgid "Workers Guide"
msgstr "ワーカー"

#: ../../userguide/workers.rst:14
msgid "Starting the worker"
msgstr "ワーカーの起動"

#: ../../userguide/workers.rst:0
msgid "Daemonizing"
msgstr "デーモン化"

#: ../../userguide/workers.rst:18
msgid ""
"You probably want to use a daemonization tool to start in the background.  "
"See :ref:`daemonizing` for help detaching the worker using popular "
"daemonization tools."
msgstr ""
"バックグラウンドで起動させるのにデーモン化ツールを使いたいことでしょう。ポピュラーなデーモン化ツールを使ってワーカーを切り離す方法については "
":ref:`daemonizing` を参考にしてください。"

#: ../../userguide/workers.rst:22
msgid "You can start the worker in the foreground by executing the command:"
msgstr "フォアグラウンドでワーカーを起動するには次のコマンドを実行します:"

#: ../../userguide/workers.rst:28
msgid ""
"For a full list of available command-line options see "
":mod:`~celery.bin.worker`, or simply do:"
msgstr ""
"利用可能なコマンドラインの全オプションについては、:mod:`~celery.bin.worker` を見るか、help オプションを使います:"

#: ../../userguide/workers.rst:35
msgid ""
"You can also start multiple workers on the same machine. If you do so be "
"sure to give a unique name to each individual worker by specifying a host "
"name with the :option:`--hostname|-n` argument:"
msgstr ""
"同じマシン上で複数のワーカーを起動することもできます。その場合は必ず :option:`--hostname|-n` "
"引数でホスト名を指定して個々のワーカーに一意な名前を付けます:"

#: ../../userguide/workers.rst:45
msgid "The hostname argument can expand the following variables:"
msgstr "hostname 引数は以下の変数を展開します:"

#: ../../userguide/workers.rst:47 ../../userguide/workers.rst:152
msgid "``%h``:  Hostname including domain name."
msgstr "``%h``:  ドメイン名を含むホスト名。"

#: ../../userguide/workers.rst:48 ../../userguide/workers.rst:153
msgid "``%n``:  Hostname only."
msgstr "``%n``:  ホスト名のみ。"

#: ../../userguide/workers.rst:49 ../../userguide/workers.rst:154
msgid "``%d``:  Domain name only."
msgstr "``%d``:  ドメイン名のみ。"

#: ../../userguide/workers.rst:51 ../../userguide/workers.rst:158
msgid ""
"E.g. if the current hostname is ``george.example.com`` then these will "
"expand to:"
msgstr "例)　現在のホスト名が ``george.exampel.com`` だったら次のように展開されます:"

#: ../../userguide/workers.rst:54
msgid "``worker1.%h`` -> ``worker1.george.example.com``"
msgstr ""

#: ../../userguide/workers.rst:55
msgid "``worker1.%n`` -> ``worker1.george``"
msgstr ""

#: ../../userguide/workers.rst:56
msgid "``worker1.%d`` -> ``worker1.example.com``"
msgstr ""

#: ../../userguide/workers.rst:65
msgid "Stopping the worker"
msgstr "ワーカーの停止"

#: ../../userguide/workers.rst:67
msgid "Shutdown should be accomplished using the :sig:`TERM` signal."
msgstr ":sig:`TERM` シグナルを使って停止させてください。"

#: ../../userguide/workers.rst:69
msgid ""
"When shutdown is initiated the worker will finish all currently executing "
"tasks before it actually terminates, so if these tasks are important you "
"should wait for it to finish before doing anything drastic (like sending the"
" :sig:`KILL` signal)."
msgstr ""
"停止処理が実行されると、ワーカーは実際に停止する前に現在実行中のすべてのタスクを完了させます。"
"なので、重要なタスクを実行している場合は(:sig:`KILL` シグナルを送るといった)ドラスティックなことをする前に、"
"タスクが完了するのを待ってください。"

#: ../../userguide/workers.rst:74
msgid ""
"If the worker won't shutdown after considerate time, for example because of "
"tasks stuck in an infinite-loop, you can use the :sig:`KILL` signal to force"
" terminate the worker, but be aware that currently executing tasks will be "
"lost (unless the tasks have the :attr:`~@Task.acks_late` option set)."
msgstr ""
"タスクが無限ループに陥っているといった理由でワーカーがいつまで経っても停止しない場合、"
":sig:`KILL` シグナルを使ってワーカーを強制的に停止させることができます。"
"但し、現在実行中のタスクは失われてしまうので気を付けてください"
"(タスクに :attr:`~@Task.acks_late` オプションがセットされていない場合)。"

#: ../../userguide/workers.rst:80
msgid ""
"Also as processes can't override the :sig:`KILL` signal, the worker will not"
" be able to reap its children, so make sure to do so manually.  This command"
" usually does the trick:"
msgstr ""

#: ../../userguide/workers.rst:91
msgid "Restarting the worker"
msgstr "ワーカーの再起動"

#: ../../userguide/workers.rst:93
msgid ""
"To restart the worker you should send the `TERM` signal and start a new "
"instance.  The easiest way to manage workers for development is by using "
"`celery multi`:"
msgstr ""
"ワーカーを再起動するには、`TERM` シグナルを送り、そして新しいインスタンスを起動します。開発中にワーカーを管理する簡単な方法は `celery "
"multi` を使うことです:"

#: ../../userguide/workers.rst:102
msgid ""
"For production deployments you should be using init scripts or other process"
" supervision systems (see :ref:`daemonizing`)."
msgstr ""
"運用環境では init スクリプトやプロセス管理ツールを使ってください。( :ref:`daemonizing` 参照)"

#: ../../userguide/workers.rst:105
msgid ""
"Other than stopping then starting the worker to restart, you can also "
"restart the worker using the :sig:`HUP` signal, but note that the worker "
"will be responsible for restarting itself so this is prone to problems and "
"is not recommended in production:"
msgstr ""
"ワーカーの再起動方法として停止と起動を行う代わりに :sig:`HUP` シグナルを使うこともできますが、"
"ワーカーが自身を再起動させる形になるため問題が生じやすく、運用環境での使用は推奨していません。"

#: ../../userguide/workers.rst:116
msgid ""
"Restarting by :sig:`HUP` only works if the worker is running in the "
"background as a daemon (it does not have a controlling terminal)."
msgstr ""
":sig:`HUP` での再起動はワーカーがデーモンとしてバックグラウンドで稼動している場合に限られます。"

#: ../../userguide/workers.rst:120
msgid ""
":sig:`HUP` is disabled on OS X because of a limitation on that platform."
msgstr ""
":sig:`HUP` はプラットフォーム上の制限のため OS X では無効化されています。"

#: ../../userguide/workers.rst:127
msgid "Process Signals"
msgstr "シグナル"

#: ../../userguide/workers.rst:129
msgid "The worker's main process overrides the following signals:"
msgstr "ワーカーのメインプロセスは以下のシグナルをオーバーライドしています:"

#: ../../userguide/workers.rst:132
msgid ":sig:`TERM`"
msgstr ""

#: ../../userguide/workers.rst:132
msgid "Warm shutdown, wait for tasks to complete."
msgstr "ウォーム停止。タスクが完了するまで待機します。"

#: ../../userguide/workers.rst:134
msgid ":sig:`QUIT`"
msgstr ""

#: ../../userguide/workers.rst:134
msgid "Cold shutdown, terminate ASAP"
msgstr "コールド停止。即座に停止します。"

#: ../../userguide/workers.rst:136
msgid ":sig:`USR1`"
msgstr ""

#: ../../userguide/workers.rst:136
msgid "Dump traceback for all active threads."
msgstr "全アクティブスレッドのトレースバックをダンプします。"

#: ../../userguide/workers.rst:138
msgid ":sig:`USR2`"
msgstr ""

#: ../../userguide/workers.rst:138
msgid "Remote debug, see :mod:`celery.contrib.rdb`."
msgstr "リモートデバッグ。 :mod:`celery.contrib.rdb` を参照。"

#: ../../userguide/workers.rst:144
msgid "Variables in file paths"
msgstr "ファイルパス内の変数"

#: ../../userguide/workers.rst:146
msgid ""
"The file path arguments for :option:`--logfile`, :option:`--pidfile` and "
":option:`--statedb` can contain variables that the worker will expand:"
msgstr ""

#: ../../userguide/workers.rst:150
msgid "Node name replacements"
msgstr ""

#: ../../userguide/workers.rst:155
msgid "``%i``:  Prefork pool process index or 0 if MainProcess."
msgstr ""

#: ../../userguide/workers.rst:156
msgid "``%I``:  Prefork pool process index with separator."
msgstr ""

#: ../../userguide/workers.rst:161
msgid "``--logfile=%h.log`` -> :file:`george.example.com.log`"
msgstr ""

#: ../../userguide/workers.rst:162
msgid "``--logfile=%n.log`` -> :file:`george.log`"
msgstr ""

#: ../../userguide/workers.rst:163
msgid "``--logfile=%d`` -> :file:`example.com.log`"
msgstr ""

#: ../../userguide/workers.rst:168
msgid "Prefork pool process index"
msgstr ""

#: ../../userguide/workers.rst:170
msgid ""
"The prefork pool process index specifiers will expand into a different "
"filename depending on the process that will eventually need to open the "
"file."
msgstr ""

#: ../../userguide/workers.rst:173
msgid "This can be used to specify one log file per child process."
msgstr ""

#: ../../userguide/workers.rst:175
msgid ""
"Note that the numbers will stay within the process limit even if processes "
"exit or if autoscale/maxtasksperchild/time limits are used.  I.e. the number"
" is the *process index* not the process count or pid."
msgstr ""

#: ../../userguide/workers.rst:179
msgid "``%i`` - Pool process index or 0 if MainProcess."
msgstr ""

#: ../../userguide/workers.rst:181
msgid ""
"Where ``-n worker1@example.com -c2 -f %n-%i.log`` will result in three log "
"files:"
msgstr ""

#: ../../userguide/workers.rst:184
msgid ":file:`worker1-0.log` (main process)"
msgstr ""

#: ../../userguide/workers.rst:185 ../../userguide/workers.rst:194
msgid ":file:`worker1-1.log` (pool process 1)"
msgstr ""

#: ../../userguide/workers.rst:186 ../../userguide/workers.rst:195
msgid ":file:`worker1-2.log` (pool process 2)"
msgstr ""

#: ../../userguide/workers.rst:188
msgid "``%I`` - Pool process index with separator."
msgstr ""

#: ../../userguide/workers.rst:190
msgid ""
"Where ``-n worker1@example.com -c2 -f %n%I.log`` will result in three log "
"files:"
msgstr ""

#: ../../userguide/workers.rst:193
msgid ":file:`worker1.log` (main process)"
msgstr ""

#: ../../userguide/workers.rst:200
msgid "Concurrency"
msgstr "並行処理"

#: ../../userguide/workers.rst:202
msgid ""
"By default multiprocessing is used to perform concurrent execution of tasks,"
" but you can also use :ref:`Eventlet <concurrency-eventlet>`.  The number of"
" worker processes/threads can be changed using the :option:`--concurrency` "
"argument and defaults to the number of CPUs available on the machine."
msgstr "タスクの並行実行にはデフォルトでは multiprocessing モジュールが使用されますが、"
" :ref:`Eventlet <concurrency-eventlet>` を使用することも可能です。"
"ワーカープロセス/スレッドの数は :option:`--concurrency` 引数を使って変更でき、"
"デフォルトではマシンの CPU 数が用いられます。"

#: ../../userguide/workers.rst:207
msgid "Number of processes (multiprocessing/prefork pool)"
msgstr "プロセス数 (multiprocessing/prefork プール)"

#: ../../userguide/workers.rst:209
msgid ""
"More pool processes are usually better, but there's a cut-off point where "
"adding more pool processes affects performance in negative ways. There is "
"even some evidence to support that having multiple worker instances running,"
" may perform better than having a single worker. For example 3 workers with "
"10 pool processes each.  You need to experiment to find the numbers that "
"works best for you, as this varies based on application, work load, task run"
" times and other factors."
msgstr ""
"通常はプールするプロセス数が多いほどパフォーマンスが上がりますが、あるカットオフポイントを超えると"
"プロセス数が増えるに連れてパフォーマンスが下がってきます。"
"けれども、例えば 10 個のプロセスプールを持つ 3 つのワーカーといった形で"
"複数のワーカーを走らせておく方が単一のワーカーより良いパフォーマンスを生み出します。"
"この最適値は、アプリケーションや負荷、タスク実行回数などの要素によって変わってくるため、"
"試行錯誤を行って導き出す必要があります。"

#: ../../userguide/workers.rst:220
msgid "Remote control"
msgstr "リモートコントロール"

#: ../../userguide/workers.rst:0
msgid "The ``celery`` command"
msgstr "``celery`` コマンド"

#: ../../userguide/workers.rst:226
msgid ""
"The :program:`celery` program is used to execute remote control commands "
"from the command-line.  It supports all of the commands listed below.  See "
":ref:`monitoring-control` for more information."
msgstr ""
":program:`celery` プログラムはコマンドラインからリモートコントロールコマンドを実行するのに使います。"
"以下のコマンドをすべてサポートしています。"
"詳しくは ref:`monitoring-control` を参照してください。"

#: ../../userguide/workers.rst:230
msgid ""
"pool support: *prefork, eventlet, gevent*, blocking:*threads/solo* (see "
"note) broker support: *amqp, redis*"
msgstr ""

#: ../../userguide/workers.rst:233
msgid ""
"Workers have the ability to be remote controlled using a high-priority "
"broadcast message queue.  The commands can be directed to all, or a specific"
" list of workers."
msgstr ""

#: ../../userguide/workers.rst:237
msgid ""
"Commands can also have replies.  The client can then wait for and collect "
"those replies.  Since there's no central authority to know how many workers "
"are available in the cluster, there is also no way to estimate how many "
"workers may send a reply, so the client has a configurable timeout — the "
"deadline in seconds for replies to arrive in.  This timeout defaults to one "
"second.  If the worker doesn't reply within the deadline it doesn't "
"necessarily mean the worker didn't reply, or worse is dead, but may simply "
"be caused by network latency or the worker being slow at processing "
"commands, so adjust the timeout accordingly."
msgstr ""

#: ../../userguide/workers.rst:247
msgid ""
"In addition to timeouts, the client can specify the maximum number of "
"replies to wait for.  If a destination is specified, this limit is set to "
"the number of destination hosts."
msgstr ""

#: ../../userguide/workers.rst:253
msgid ""
"The solo and threads pool supports remote control commands, but any task "
"executing will block any waiting control command, so it is of limited use if"
" the worker is very busy.  In that case you must increase the timeout "
"waiting for replies in the client."
msgstr ""

#: ../../userguide/workers.rst:261
msgid "The :meth:`~@control.broadcast` function."
msgstr ""

#: ../../userguide/workers.rst:263
msgid ""
"This is the client function used to send commands to the workers. Some "
"remote control commands also have higher-level interfaces using "
":meth:`~@control.broadcast` in the background, like "
":meth:`~@control.rate_limit` and :meth:`~@control.ping`."
msgstr ""

#: ../../userguide/workers.rst:268
msgid "Sending the :control:`rate_limit` command and keyword arguments::"
msgstr ""

#: ../../userguide/workers.rst:274
msgid ""
"This will send the command asynchronously, without waiting for a reply. To "
"request a reply you have to use the `reply` argument::"
msgstr ""

#: ../../userguide/workers.rst:283
msgid ""
"Using the `destination` argument you can specify a list of workers to "
"receive the command::"
msgstr ""

#: ../../userguide/workers.rst:293
msgid ""
"Of course, using the higher-level interface to set rate limits is much more "
"convenient, but there are commands that can only be requested using "
":meth:`~@control.broadcast`."
msgstr ""

#: ../../userguide/workers.rst:298
msgid "Commands"
msgstr ""

#: ../../userguide/workers.rst:303
msgid "``revoke``: Revoking tasks"
msgstr ""

#: ../../userguide/workers.rst:304
msgid "all"
msgstr ""

#: ../../userguide/workers.rst:305
msgid "*amqp, redis*"
msgstr ""

#: ../../userguide/workers.rst:306
msgid ":program:`celery -A proj control revoke <task_id>`"
msgstr ""

#: ../../userguide/workers.rst:308
msgid ""
"All worker nodes keeps a memory of revoked task ids, either in-memory or "
"persistent on disk (see :ref:`worker-persistent-revokes`)."
msgstr ""

#: ../../userguide/workers.rst:311
msgid ""
"When a worker receives a revoke request it will skip executing the task, but"
" it won't terminate an already executing task unless the `terminate` option "
"is set."
msgstr ""

#: ../../userguide/workers.rst:317
msgid ""
"The terminate option is a last resort for administrators when a task is "
"stuck.  It's not for terminating the task, it's for terminating the process "
"that is executing the task, and that process may have already started "
"processing another task at the point when the signal is sent, so for this "
"rason you must never call this programatically."
msgstr ""

#: ../../userguide/workers.rst:324
msgid ""
"If `terminate` is set the worker child process processing the task will be "
"terminated.  The default signal sent is `TERM`, but you can specify this "
"using the `signal` argument.  Signal can be the uppercase name of any signal"
" defined in the :mod:`signal` module in the Python Standard Library."
msgstr ""

#: ../../userguide/workers.rst:330
msgid "Terminating a task also revokes it."
msgstr ""

#: ../../userguide/workers.rst:332 ../../userguide/workers.rst:360
msgid "**Example**"
msgstr ""

#: ../../userguide/workers.rst:352
msgid "Revoking multiple tasks"
msgstr ""

#: ../../userguide/workers.rst:357
msgid ""
"The revoke method also accepts a list argument, where it will revoke several"
" tasks at once."
msgstr ""

#: ../../userguide/workers.rst:371
msgid ""
"The ``GroupResult.revoke`` method takes advantage of this since version 3.1."
msgstr ""

#: ../../userguide/workers.rst:377
msgid "Persistent revokes"
msgstr ""

#: ../../userguide/workers.rst:379
msgid ""
"Revoking tasks works by sending a broadcast message to all the workers, the "
"workers then keep a list of revoked tasks in memory.  When a worker starts "
"up it will synchronize revoked tasks with other workers in the cluster."
msgstr ""

#: ../../userguide/workers.rst:383
msgid ""
"The list of revoked tasks is in-memory so if all workers restart the list of"
" revoked ids will also vanish.  If you want to preserve this list between "
"restarts you need to specify a file for these to be stored in by using the "
"`--statedb` argument to :program:`celery worker`:"
msgstr ""

#: ../../userguide/workers.rst:392
msgid ""
"or if you use :program:`celery multi` you will want to create one file per "
"worker instance so then you can use the `%n` format to expand the current "
"node name:"
msgstr ""

#: ../../userguide/workers.rst:401
msgid "See also :ref:`worker-files`"
msgstr ""

#: ../../userguide/workers.rst:403
msgid ""
"Note that remote control commands must be working for revokes to work. "
"Remote control commands are only supported by the RabbitMQ (amqp) and Redis "
"at this point."
msgstr ""

#: ../../userguide/workers.rst:410
msgid "Time Limits"
msgstr "タイムリミット"

#: ../../userguide/workers.rst:414
msgid "pool support: *prefork/gevent*"
msgstr ""

#: ../../userguide/workers.rst:0
msgid "Soft, or hard?"
msgstr "ソフト or ハード？"

#: ../../userguide/workers.rst:418
msgid ""
"The time limit is set in two values, `soft` and `hard`. The soft time limit "
"allows the task to catch an exception to clean up before it is killed: the "
"hard timeout is not catchable and force terminates the task."
msgstr ""
"タイムリミットには `ソフト` と `ハード` の二つの値があります。"
"ソフトタイムリミットでは、タスクは例外をキャッチしてプロセスが kill される前にクリンナップ処理を実行できます。"
"一方ハードタイムリミットはキャッチできず、タスクは強制的に停止されます。"

#: ../../userguide/workers.rst:423
msgid ""
"A single task can potentially run forever, if you have lots of tasks waiting"
" for some event that will never happen you will block the worker from "
"processing new tasks indefinitely.  The best way to defend against this "
"scenario happening is enabling time limits."
msgstr ""
"ひとつのタスクが永遠に実行されることはあり得ます。"
"決して起こり得ないイベントを待つタスクが多数ある場合、ワーカーが新しいタスクを処理するのを永久にブロックしてしまいます。"
"このような事態に備える最良の方法は時間制限を有効にすることです。"

#: ../../userguide/workers.rst:428
msgid ""
"The time limit (`--time-limit`) is the maximum number of seconds a task may "
"run before the process executing it is terminated and replaced by a new "
"process.  You can also enable a soft time limit (`--soft-time-limit`), this "
"raises an exception the task can catch to clean up before the hard time "
"limit kills it:"
msgstr ""
"タイムリミット(`--time-limit`)ではタスク処理の最大実行時間を指定します。"
"この時間を超えるとタスク処理は停止され、新しいプロセスに置き変わります。"
"ソフトタイムリミット(`--soft-time-limit`)を有効にすると、タイムオーバーの際に例外が送出されます。"
"タスクはこの例外をキャッチして、ハードタイムリミットによってプロセスが kill される前に"
"クリンナップ処理を行うことができます。"

#: ../../userguide/workers.rst:446
msgid ""
"Time limits can also be set using the :setting:`CELERYD_TASK_TIME_LIMIT` / "
":setting:`CELERYD_TASK_SOFT_TIME_LIMIT` settings."
msgstr ""
"タイムリミットは :setting:`CELERYD_TASK_TIME_LIMIT` / :setting:`CELERYD_TASK_SOFT_TIME_LIMIT` で設定します。"

#: ../../userguide/workers.rst:451
msgid ""
"Time limits do not currently work on Windows and other platforms that do not"
" support the ``SIGUSR1`` signal."
msgstr ""
"タイムリミットは Windows や ``SIGUSR1`` シグナルをサポートしていないプラットフォームでは現在機能しません。"

#: ../../userguide/workers.rst:456
msgid "Changing time limits at runtime"
msgstr "動的なタイムリミットの変更"

#: ../../userguide/workers.rst:459
msgid "broker support: *amqp, redis*"
msgstr ""

#: ../../userguide/workers.rst:461
msgid ""
"There is a remote control command that enables you to change both soft and "
"hard time limits for a task — named ``time_limit``."
msgstr ""
"タスクのソフト及びハードタイムリミットを変更するリモートコントロールコマンドの ``time_limit`` が用意されています。"

#: ../../userguide/workers.rst:464
msgid ""
"Example changing the time limit for the ``tasks.crawl_the_web`` task to have"
" a soft time limit of one minute, and a hard time limit of two minutes::"
msgstr ""

#: ../../userguide/workers.rst:472
msgid ""
"Only tasks that starts executing after the time limit change will be "
"affected."
msgstr ""

#: ../../userguide/workers.rst:477
msgid "Rate Limits"
msgstr ""

#: ../../userguide/workers.rst:482
msgid "Changing rate-limits at runtime"
msgstr ""

#: ../../userguide/workers.rst:484
msgid ""
"Example changing the rate limit for the `myapp.mytask` task to execute at "
"most 200 tasks of that type every minute:"
msgstr ""

#: ../../userguide/workers.rst:491
msgid ""
"The above does not specify a destination, so the change request will affect "
"all worker instances in the cluster.  If you only want to affect a specific "
"list of workers you can include the ``destination`` argument:"
msgstr ""

#: ../../userguide/workers.rst:502
msgid ""
"This won't affect workers with the :setting:`CELERY_DISABLE_RATE_LIMITS` "
"setting enabled."
msgstr ""

#: ../../userguide/workers.rst:508
msgid "Max tasks per child setting"
msgstr ""

#: ../../userguide/workers.rst:512
msgid "pool support: *prefork*"
msgstr ""

#: ../../userguide/workers.rst:514
msgid ""
"With this option you can configure the maximum number of tasks a worker can "
"execute before it's replaced by a new process."
msgstr ""

#: ../../userguide/workers.rst:517
msgid ""
"This is useful if you have memory leaks you have no control over for example"
" from closed source C extensions."
msgstr ""

#: ../../userguide/workers.rst:520
msgid ""
"The option can be set using the workers `--maxtasksperchild` argument or "
"using the :setting:`CELERYD_MAX_TASKS_PER_CHILD` setting."
msgstr ""

#: ../../userguide/workers.rst:526
msgid "Autoscaling"
msgstr ""

#: ../../userguide/workers.rst:530
msgid "pool support: *prefork*, *gevent*"
msgstr ""

#: ../../userguide/workers.rst:532
msgid ""
"The *autoscaler* component is used to dynamically resize the pool based on "
"load:"
msgstr ""

#: ../../userguide/workers.rst:536
msgid "The autoscaler adds more pool processes when there is work to do,"
msgstr ""

#: ../../userguide/workers.rst:536
msgid "and starts removing processes when the workload is low."
msgstr ""

#: ../../userguide/workers.rst:538
msgid ""
"It's enabled by the :option:`--autoscale` option, which needs two numbers: "
"the maximum and minimum number of pool processes::"
msgstr ""

#: ../../userguide/workers.rst:547
msgid ""
"You can also define your own rules for the autoscaler by subclassing "
":class:`~celery.worker.autoscaler.Autoscaler`. Some ideas for metrics "
"include load average or the amount of memory available. You can specify a "
"custom autoscaler with the :setting:`CELERYD_AUTOSCALER` setting."
msgstr ""

#: ../../userguide/workers.rst:555
msgid "Queues"
msgstr "キュー"

#: ../../userguide/workers.rst:557
msgid ""
"A worker instance can consume from any number of queues. By default it will "
"consume from all queues defined in the :setting:`CELERY_QUEUES` setting "
"(which if not specified defaults to the queue named ``celery``)."
msgstr ""
"ワーカーインスタンスは複数のキューを consume できます。"
"デフォルトでは :setting:`CELERY_QUEUES` 設定で定義されているすべてのキューを consume します"
"(定義されていない場合はデフォルトのキュー名 ``celery`` が使われます)。"

#: ../../userguide/workers.rst:562
msgid ""
"You can specify what queues to consume from at startup, by giving a comma "
"separated list of queues to the :option:`-Q` option:"
msgstr ""
"ワーカーの起動時に :option:`-Q` オプションでカンマ区切りのキューリストを指定して"
" consume するキューを決定します。"

#: ../../userguide/workers.rst:569
msgid ""
"If the queue name is defined in :setting:`CELERY_QUEUES` it will use that "
"configuration, but if it's not defined in the list of queues Celery will "
"automatically generate a new queue for you (depending on the "
":setting:`CELERY_CREATE_MISSING_QUEUES` option)."
msgstr ""

#: ../../userguide/workers.rst:574
msgid ""
"You can also tell the worker to start and stop consuming from a queue at "
"runtime using the remote control commands :control:`add_consumer` and "
":control:`cancel_consumer`."
msgstr ""

#: ../../userguide/workers.rst:581
msgid "Queues: Adding consumers"
msgstr "キュー: コンシューマーの追加"

#: ../../userguide/workers.rst:583
msgid ""
"The :control:`add_consumer` control command will tell one or more workers to"
" start consuming from a queue. This operation is idempotent."
msgstr ""

#: ../../userguide/workers.rst:586
msgid ""
"To tell all workers in the cluster to start consuming from a queue named "
"\"``foo``\" you can use the :program:`celery control` program:"
msgstr ""

#: ../../userguide/workers.rst:595
msgid ""
"If you want to specify a specific worker you can use the "
":option:`--destination`` argument:"
msgstr ""

#: ../../userguide/workers.rst:602
msgid ""
"The same can be accomplished dynamically using the "
":meth:`@control.add_consumer` method::"
msgstr ""

#: ../../userguide/workers.rst:612
msgid ""
"By now I have only shown examples using automatic queues, If you need more "
"control you can also specify the exchange, routing_key and even other "
"options::"
msgstr ""

#: ../../userguide/workers.rst:632
msgid "Queues: Cancelling consumers"
msgstr "キュー: コンシューマーのキャンセル"

#: ../../userguide/workers.rst:634
msgid ""
"You can cancel a consumer by queue name using the :control:`cancel_consumer`"
" control command."
msgstr ""

#: ../../userguide/workers.rst:637
msgid ""
"To force all workers in the cluster to cancel consuming from a queue you can"
" use the :program:`celery control` program:"
msgstr ""

#: ../../userguide/workers.rst:644
msgid ""
"The :option:`--destination` argument can be used to specify a worker, or a "
"list of workers, to act on the command:"
msgstr ""

#: ../../userguide/workers.rst:652
msgid ""
"You can also cancel consumers programmatically using the "
":meth:`@control.cancel_consumer` method:"
msgstr ""

#: ../../userguide/workers.rst:663
msgid "Queues: List of active queues"
msgstr "キュー: アクティブなキューのリスト"

#: ../../userguide/workers.rst:665
msgid ""
"You can get a list of queues that a worker consumes from by using the "
":control:`active_queues` control command:"
msgstr ""

#: ../../userguide/workers.rst:673
msgid ""
"Like all other remote control commands this also supports the "
":option:`--destination` argument used to specify which workers should reply "
"to the request:"
msgstr ""

#: ../../userguide/workers.rst:683
msgid ""
"This can also be done programmatically by using the "
":meth:`@control.inspect.active_queues` method::"
msgstr ""

#: ../../userguide/workers.rst:695
msgid "Autoreloading"
msgstr "オートリロード"

#: ../../userguide/workers.rst:699
msgid "pool support: *prefork, eventlet, gevent, threads, solo*"
msgstr ""

#: ../../userguide/workers.rst:701
msgid ""
"Starting :program:`celery worker` with the :option:`--autoreload` option "
"will enable the worker to watch for file system changes to all imported task"
" modules imported (and also any non-task modules added to the "
":setting:`CELERY_IMPORTS` setting or the :option:`-I|--include` option)."
msgstr ""

#: ../../userguide/workers.rst:706
msgid ""
"This is an experimental feature intended for use in development only, using "
"auto-reload in production is discouraged as the behavior of reloading a "
"module in Python is undefined, and may cause hard to diagnose bugs and "
"crashes.  Celery uses the same approach as the auto-reloader found in e.g. "
"the Django ``runserver`` command."
msgstr ""

#: ../../userguide/workers.rst:712
msgid ""
"When auto-reload is enabled the worker starts an additional thread that "
"watches for changes in the file system.  New modules are imported, and "
"already imported modules are reloaded whenever a change is detected, and if "
"the prefork pool is used the child processes will finish the work they are "
"doing and exit, so that they can be replaced by fresh processes effectively "
"reloading the code."
msgstr ""

#: ../../userguide/workers.rst:719
msgid ""
"File system notification backends are pluggable, and it comes with three "
"implementations:"
msgstr ""

#: ../../userguide/workers.rst:722
msgid "inotify (Linux)"
msgstr ""

#: ../../userguide/workers.rst:724
msgid ""
"Used if the :mod:`pyinotify` library is installed. If you are running on "
"Linux this is the recommended implementation, to install the "
":mod:`pyinotify` library you have to run the following command:"
msgstr ""

#: ../../userguide/workers.rst:733
msgid "kqueue (OS X/BSD)"
msgstr ""

#: ../../userguide/workers.rst:735
msgid "stat"
msgstr ""

#: ../../userguide/workers.rst:737
msgid ""
"The fallback implementation simply polls the files using ``stat`` and is "
"very expensive."
msgstr ""

#: ../../userguide/workers.rst:740
msgid ""
"You can force an implementation by setting the :envvar:`CELERYD_FSNOTIFY` "
"environment variable:"
msgstr ""

#: ../../userguide/workers.rst:752
msgid "Pool Restart Command"
msgstr ""

#: ../../userguide/workers.rst:756
msgid "Requires the :setting:`CELERYD_POOL_RESTARTS` setting to be enabled."
msgstr ""

#: ../../userguide/workers.rst:758
msgid ""
"The remote control command :control:`pool_restart` sends restart requests to"
" the workers child processes.  It is particularly useful for forcing the "
"worker to import new modules, or for reloading already imported modules.  "
"This command does not interrupt executing tasks."
msgstr ""

#: ../../userguide/workers.rst:764
msgid "Example"
msgstr ""

#: ../../userguide/workers.rst:766
msgid ""
"Running the following command will result in the `foo` and `bar` modules "
"being imported by the worker processes:"
msgstr ""

#: ../../userguide/workers.rst:774
msgid "Use the ``reload`` argument to reload modules it has already imported:"
msgstr ""

#: ../../userguide/workers.rst:782
msgid ""
"If you don't specify any modules then all known tasks modules will be "
"imported/reloaded:"
msgstr ""

#: ../../userguide/workers.rst:789
msgid ""
"The ``modules`` argument is a list of modules to modify. ``reload`` "
"specifies whether to reload modules if they have previously been imported. "
"By default ``reload`` is disabled. The `pool_restart` command uses the "
"Python :func:`reload` function to reload modules, or you can provide your "
"own custom reloader by passing the ``reloader`` argument."
msgstr ""

#: ../../userguide/workers.rst:797
msgid ""
"Module reloading comes with caveats that are documented in :func:`reload`. "
"Please read this documentation and make sure your modules are suitable for "
"reloading."
msgstr ""

#: ../../userguide/workers.rst:803
msgid "http://pyunit.sourceforge.net/notes/reloading.html"
msgstr ""

#: ../../userguide/workers.rst:804
msgid "http://www.indelible.org/ink/python-reloading/"
msgstr ""

#: ../../userguide/workers.rst:805
msgid "http://docs.python.org/library/functions.html#reload"
msgstr ""

#: ../../userguide/workers.rst:811
msgid "Inspecting workers"
msgstr ""

#: ../../userguide/workers.rst:813
msgid ""
":class:`@control.inspect` lets you inspect running workers.  It uses remote "
"control commands under the hood."
msgstr ""

#: ../../userguide/workers.rst:834
msgid "Dump of registered tasks"
msgstr ""

#: ../../userguide/workers.rst:836
msgid ""
"You can get a list of tasks registered in the worker using the "
":meth:`~@control.inspect.registered`::"
msgstr ""

#: ../../userguide/workers.rst:846
msgid "Dump of currently executing tasks"
msgstr ""

#: ../../userguide/workers.rst:848
msgid ""
"You can get a list of active tasks using :meth:`~@control.inspect.active`::"
msgstr ""

#: ../../userguide/workers.rst:861
msgid "Dump of scheduled (ETA) tasks"
msgstr ""

#: ../../userguide/workers.rst:863
msgid ""
"You can get a list of tasks waiting to be scheduled by using "
":meth:`~@control.inspect.scheduled`::"
msgstr ""

#: ../../userguide/workers.rst:883
msgid "These are tasks with an eta/countdown argument, not periodic tasks."
msgstr ""

#: ../../userguide/workers.rst:888
msgid "Dump of reserved tasks"
msgstr ""

#: ../../userguide/workers.rst:890
msgid ""
"Reserved tasks are tasks that has been received, but is still waiting to be "
"executed."
msgstr ""

#: ../../userguide/workers.rst:893
msgid "You can get a list of these using :meth:`~@control.inspect.reserved`::"
msgstr ""

#: ../../userguide/workers.rst:907
msgid "Statistics"
msgstr ""

#: ../../userguide/workers.rst:909
msgid ""
"The remote control command ``inspect stats`` (or "
":meth:`~@control.inspect.stats`) will give you a long list of useful (or not"
" so useful) statistics about the worker:"
msgstr ""

#: ../../userguide/workers.rst:917
msgid "The output will include the following fields:"
msgstr ""

#: ../../userguide/workers.rst:919
msgid "``broker``"
msgstr ""

#: ../../userguide/workers.rst:921
msgid "Section for broker information."
msgstr ""

#: ../../userguide/workers.rst:923
msgid "``connect_timeout``"
msgstr ""

#: ../../userguide/workers.rst:925
msgid "Timeout in seconds (int/float) for establishing a new connection."
msgstr ""

#: ../../userguide/workers.rst:927
msgid "``heartbeat``"
msgstr ""

#: ../../userguide/workers.rst:929
msgid "Current heartbeat value (set by client)."
msgstr ""

#: ../../userguide/workers.rst:931
msgid "``hostname``"
msgstr ""

#: ../../userguide/workers.rst:933
msgid "Hostname of the remote broker."
msgstr ""

#: ../../userguide/workers.rst:935
msgid "``insist``"
msgstr ""

#: ../../userguide/workers.rst:937
msgid "No longer used."
msgstr ""

#: ../../userguide/workers.rst:939
msgid "``login_method``"
msgstr ""

#: ../../userguide/workers.rst:941
msgid "Login method used to connect to the broker."
msgstr ""

#: ../../userguide/workers.rst:943
msgid "``port``"
msgstr ""

#: ../../userguide/workers.rst:945
msgid "Port of the remote broker."
msgstr ""

#: ../../userguide/workers.rst:947
msgid "``ssl``"
msgstr ""

#: ../../userguide/workers.rst:949
msgid "SSL enabled/disabled."
msgstr ""

#: ../../userguide/workers.rst:951
msgid "``transport``"
msgstr ""

#: ../../userguide/workers.rst:953
msgid "Name of transport used (e.g. ``amqp`` or ``redis``)"
msgstr ""

#: ../../userguide/workers.rst:955
msgid "``transport_options``"
msgstr ""

#: ../../userguide/workers.rst:957
msgid "Options passed to transport."
msgstr ""

#: ../../userguide/workers.rst:959
msgid "``uri_prefix``"
msgstr ""

#: ../../userguide/workers.rst:961
msgid ""
"Some transports expects the host name to be an URL, this applies to for "
"example SQLAlchemy where the host name part is the connection URI:"
msgstr ""

#: ../../userguide/workers.rst:964
msgid "redis+socket:///tmp/redis.sock"
msgstr ""

#: ../../userguide/workers.rst:966
msgid "In this example the uri prefix will be ``redis``."
msgstr ""

#: ../../userguide/workers.rst:968
msgid "``userid``"
msgstr ""

#: ../../userguide/workers.rst:970
msgid "User id used to connect to the broker with."
msgstr ""

#: ../../userguide/workers.rst:972
msgid "``virtual_host``"
msgstr ""

#: ../../userguide/workers.rst:974
msgid "Virtual host used."
msgstr ""

#: ../../userguide/workers.rst:976
msgid "``clock``"
msgstr ""

#: ../../userguide/workers.rst:978
msgid ""
"Value of the workers logical clock.  This is a positive integer and should "
"be increasing every time you receive statistics."
msgstr ""

#: ../../userguide/workers.rst:981
msgid "``pid``"
msgstr ""

#: ../../userguide/workers.rst:983
msgid "Process id of the worker instance (Main process)."
msgstr ""

#: ../../userguide/workers.rst:985
msgid "``pool``"
msgstr ""

#: ../../userguide/workers.rst:987
msgid "Pool-specific section."
msgstr ""

#: ../../userguide/workers.rst:989
msgid "``max-concurrency``"
msgstr ""

#: ../../userguide/workers.rst:991
msgid "Max number of processes/threads/green threads."
msgstr ""

#: ../../userguide/workers.rst:993
msgid "``max-tasks-per-child``"
msgstr ""

#: ../../userguide/workers.rst:995
msgid "Max number of tasks a thread may execute before being recycled."
msgstr ""

#: ../../userguide/workers.rst:997
msgid "``processes``"
msgstr ""

#: ../../userguide/workers.rst:999
msgid "List of pids (or thread-id's)."
msgstr ""

#: ../../userguide/workers.rst:1001
msgid "``put-guarded-by-semaphore``"
msgstr ""

#: ../../userguide/workers.rst:1003
msgid "Internal"
msgstr ""

#: ../../userguide/workers.rst:1005
msgid "``timeouts``"
msgstr ""

#: ../../userguide/workers.rst:1007
msgid "Default values for time limits."
msgstr ""

#: ../../userguide/workers.rst:1009
msgid "``writes``"
msgstr ""

#: ../../userguide/workers.rst:1011
msgid ""
"Specific to the prefork pool, this shows the distribution of writes to each "
"process in the pool when using async I/O."
msgstr ""

#: ../../userguide/workers.rst:1014
msgid "``prefetch_count``"
msgstr ""

#: ../../userguide/workers.rst:1016
msgid "Current prefetch count value for the task consumer."
msgstr ""

#: ../../userguide/workers.rst:1018
msgid "``rusage``"
msgstr ""

#: ../../userguide/workers.rst:1020
msgid ""
"System usage statistics.  The fields available may be different on your "
"platform."
msgstr ""

#: ../../userguide/workers.rst:1023
msgid "From :manpage:`getrusage(2)`:"
msgstr ""

#: ../../userguide/workers.rst:1025
msgid "``stime``"
msgstr ""

#: ../../userguide/workers.rst:1027
msgid "Time spent in operating system code on behalf of this process."
msgstr ""

#: ../../userguide/workers.rst:1029
msgid "``utime``"
msgstr ""

#: ../../userguide/workers.rst:1031
msgid "Time spent executing user instructions."
msgstr ""

#: ../../userguide/workers.rst:1033
msgid "``maxrss``"
msgstr ""

#: ../../userguide/workers.rst:1035
msgid "The maximum resident size used by this process (in kilobytes)."
msgstr ""

#: ../../userguide/workers.rst:1037
msgid "``idrss``"
msgstr ""

#: ../../userguide/workers.rst:1039
msgid ""
"Amount of unshared memory used for data (in kilobytes times ticks of "
"execution)"
msgstr ""

#: ../../userguide/workers.rst:1042
msgid "``isrss``"
msgstr ""

#: ../../userguide/workers.rst:1044
msgid ""
"Amount of unshared memory used for stack space (in kilobytes times ticks of "
"execution)"
msgstr ""

#: ../../userguide/workers.rst:1047
msgid "``ixrss``"
msgstr ""

#: ../../userguide/workers.rst:1049
msgid ""
"Amount of memory shared with other processes (in kilobytes times ticks of "
"execution)."
msgstr ""

#: ../../userguide/workers.rst:1052
msgid "``inblock``"
msgstr ""

#: ../../userguide/workers.rst:1054
msgid ""
"Number of times the file system had to read from the disk on behalf of this "
"process."
msgstr ""

#: ../../userguide/workers.rst:1057
msgid "``oublock``"
msgstr ""

#: ../../userguide/workers.rst:1059
msgid ""
"Number of times the file system has to write to disk on behalf of this "
"process."
msgstr ""

#: ../../userguide/workers.rst:1062
msgid "``majflt``"
msgstr ""

#: ../../userguide/workers.rst:1064
msgid "Number of page faults which were serviced by doing I/O."
msgstr ""

#: ../../userguide/workers.rst:1066
msgid "``minflt``"
msgstr ""

#: ../../userguide/workers.rst:1068
msgid "Number of page faults which were serviced without doing I/O."
msgstr ""

#: ../../userguide/workers.rst:1070
msgid "``msgrcv``"
msgstr ""

#: ../../userguide/workers.rst:1072
msgid "Number of IPC messages received."
msgstr ""

#: ../../userguide/workers.rst:1074
msgid "``msgsnd``"
msgstr ""

#: ../../userguide/workers.rst:1076
msgid "Number of IPC messages sent."
msgstr ""

#: ../../userguide/workers.rst:1078
msgid "``nvcsw``"
msgstr ""

#: ../../userguide/workers.rst:1080
msgid "Number of times this process voluntarily invoked a context switch."
msgstr ""

#: ../../userguide/workers.rst:1082
msgid "``nivcsw``"
msgstr ""

#: ../../userguide/workers.rst:1084
msgid "Number of times an involuntary context switch took place."
msgstr ""

#: ../../userguide/workers.rst:1086
msgid "``nsignals``"
msgstr ""

#: ../../userguide/workers.rst:1088
msgid "Number of signals received."
msgstr ""

#: ../../userguide/workers.rst:1090
msgid "``nswap``"
msgstr ""

#: ../../userguide/workers.rst:1092
msgid "The number of times this process was swapped entirely out of memory."
msgstr ""

#: ../../userguide/workers.rst:1095
msgid "``total``"
msgstr ""

#: ../../userguide/workers.rst:1097
msgid ""
"List of task names and a total number of times that task have been executed "
"since worker start."
msgstr ""

#: ../../userguide/workers.rst:1102
msgid "Additional Commands"
msgstr ""

#: ../../userguide/workers.rst:1107
msgid "Remote shutdown"
msgstr ""

#: ../../userguide/workers.rst:1109
msgid "This command will gracefully shut down the worker remotely:"
msgstr ""

#: ../../userguide/workers.rst:1119
msgid "Ping"
msgstr ""

#: ../../userguide/workers.rst:1121
msgid ""
"This command requests a ping from alive workers. The workers reply with the "
"string 'pong', and that's just about it. It will use the default one second "
"timeout for replies unless you specify a custom timeout:"
msgstr ""

#: ../../userguide/workers.rst:1133
msgid ""
":meth:`~@control.ping` also supports the `destination` argument, so you can "
"specify which workers to ping::"
msgstr ""

#: ../../userguide/workers.rst:1146
msgid "Enable/disable events"
msgstr ""

#: ../../userguide/workers.rst:1148
msgid ""
"You can enable/disable events by using the `enable_events`, `disable_events`"
" commands.  This is useful to temporarily monitor a worker using "
":program:`celery events`/:program:`celerymon`."
msgstr ""

#: ../../userguide/workers.rst:1160
msgid "Writing your own remote control commands"
msgstr ""

#: ../../userguide/workers.rst:1162
msgid ""
"Remote control commands are registered in the control panel and they take a "
"single argument: the current :class:`~celery.worker.control.ControlDispatch`"
" instance. From there you have access to the active "
":class:`~celery.worker.consumer.Consumer` if needed."
msgstr ""

#: ../../userguide/workers.rst:1168
msgid ""
"Here's an example control command that increments the task prefetch count:"
msgstr ""

#: ../../userguide/workers.rst:58
msgid "Note for :program:`supervisord` users."
msgstr ":program:`supervisord` を使う場合"

#: ../../userguide/workers.rst:60
msgid "The ``%`` sign must be escaped by adding a second one: `%%h`."
msgstr "``%`` 記号はもう一つ並べてエスケープして記述します: `%%h`"

#: ../../userguide/workers.rst:816
msgid ""
"You can also use the ``celery`` command to inspect workers, and it supports "
"the same commands as the :class:`@control` interface."
msgstr ""

