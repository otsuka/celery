# 
msgid ""
msgstr ""
"Project-Id-Version: Celery 3.1\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2014-06-10 16:05+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../userguide/tasks.rst:5
msgid "Tasks"
msgstr ""

#: ../../userguide/tasks.rst:7
msgid "Tasks are the building blocks of Celery applications."
msgstr ""

#: ../../userguide/tasks.rst:9
msgid ""
"A task is a class that can be created out of any callable. It performs dual "
"roles in that it defines both what happens when a task is called (sends a "
"message), and what happens when a worker receives that message."
msgstr ""

#: ../../userguide/tasks.rst:13
msgid ""
"Every task class has a unique name, and this name is referenced in messages "
"so that the worker can find the right function to execute."
msgstr ""

#: ../../userguide/tasks.rst:16
msgid ""
"A task message does not disappear until the message has been "
":term:`acknowledged` by a worker. A worker can reserve many messages in "
"advance and even if the worker is killed -- caused by power failure or "
"otherwise -- the message will be redelivered to another worker."
msgstr ""

#: ../../userguide/tasks.rst:21
msgid ""
"Ideally task functions should be :term:`idempotent`, which means that the "
"function will not cause unintented effects even if called multiple times "
"with the same arguments. Since the worker cannot detect if your tasks are "
"idempotent, the default behavior is to acknowledge the message in advance, "
"before it's executed, so that a task that has already been started is never "
"executed again.."
msgstr ""

#: ../../userguide/tasks.rst:28
msgid ""
"If your task is idempotent you can set the :attr:`acks_late` option to have "
"the worker acknowledge the message *after* the task returns instead.  See "
"also the FAQ entry :ref:`faq-acks_late-vs-retry`."
msgstr ""

#: ../../userguide/tasks.rst:32
msgid "--"
msgstr ""

#: ../../userguide/tasks.rst:34
msgid ""
"In this chapter you will learn all about defining tasks, and this is the "
"**table of contents**:"
msgstr ""

#: ../../userguide/tasks.rst:45
msgid "Basics"
msgstr ""

#: ../../userguide/tasks.rst:47
msgid ""
"You can easily create a task from any callable by using the "
":meth:`~@Celery.task` decorator:"
msgstr ""

#: ../../userguide/tasks.rst:59
msgid ""
"There are also many :ref:`options <task-options>` that can be set for the "
"task, these can be specified as arguments to the decorator:"
msgstr ""

#: ../../userguide/tasks.rst:0
msgid "How do I import the task decorator? And what is \"app\"?"
msgstr ""

#: ../../userguide/tasks.rst:72
msgid ""
"The task decorator is available on your :class:`@Celery` application "
"instance, if you don't know what that is then please read :ref:`first-"
"steps`."
msgstr ""

#: ../../userguide/tasks.rst:75
msgid ""
"If you're using Django or are still using the \"old\" module based celery "
"API, then you can import the task decorator like this::"
msgstr ""

#: ../../userguide/tasks.rst:0
msgid "Multiple decorators"
msgstr ""

#: ../../userguide/tasks.rst:86
msgid ""
"When using multiple decorators in combination with the task decorator you "
"must make sure that the `task` decorator is applied last (which in Python "
"oddly means that it must be the first in the list):"
msgstr ""

#: ../../userguide/tasks.rst:102
msgid "Names"
msgstr ""

#: ../../userguide/tasks.rst:104
msgid ""
"Every task must have a unique name, and a new name will be generated out of "
"the function name if a custom name is not provided."
msgstr ""

#: ../../userguide/tasks.rst:107
msgid "For example:"
msgstr ""

#: ../../userguide/tasks.rst:118
msgid ""
"A best practice is to use the module name as a namespace, this way names "
"won't collide if there's already a task with that name defined in another "
"module."
msgstr ""

#: ../../userguide/tasks.rst:128
msgid ""
"You can tell the name of the task by investigating its name attribute::"
msgstr ""

#: ../../userguide/tasks.rst:133
msgid ""
"Which is exactly the name that would have been generated anyway, if the "
"module name is \"tasks.py\":"
msgstr ""

#: ../../userguide/tasks.rst:136
msgid ":file:`tasks.py`:"
msgstr ""

#: ../../userguide/tasks.rst:151
msgid "Automatic naming and relative imports"
msgstr ""

#: ../../userguide/tasks.rst:153
msgid ""
"Relative imports and automatic name generation does not go well together, so"
" if you're using relative imports you should set the name explicitly."
msgstr ""

#: ../../userguide/tasks.rst:156
msgid ""
"For example if the client imports the module \"myapp.tasks\" as \".tasks\", "
"and the worker imports the module as \"myapp.tasks\", the generated names "
"won't match and an :exc:`~@NotRegistered` error will be raised by the "
"worker."
msgstr ""

#: ../../userguide/tasks.rst:160
msgid ""
"This is also the case when using Django and using `project.myapp`-style "
"naming in ``INSTALLED_APPS``:"
msgstr ""

#: ../../userguide/tasks.rst:167
msgid ""
"If you install the app under the name ``project.myapp`` then the tasks "
"module will be imported as ``project.myapp.tasks``, so you must make sure "
"you always import the tasks using the same name:"
msgstr ""

#: ../../userguide/tasks.rst:177
msgid ""
"The second example will cause the task to be named differently since the "
"worker and the client imports the modules under different names:"
msgstr ""

#: ../../userguide/tasks.rst:190
msgid ""
"So for this reason you must be consistent in how you import modules, which "
"is also a Python best practice."
msgstr ""

#: ../../userguide/tasks.rst:193
msgid "Similarly, you should not use old-style relative imports:"
msgstr ""

#: ../../userguide/tasks.rst:201
msgid "New-style relative imports are fine and can be used:"
msgstr ""

#: ../../userguide/tasks.rst:207
msgid ""
"If you want to use Celery with a project already using these patterns "
"extensively and you don't have the time to refactor the existing code then "
"you can consider specifying the names explicitly instead of relying on the "
"automatic naming:"
msgstr ""

#: ../../userguide/tasks.rst:221
msgid "Context"
msgstr ""

#: ../../userguide/tasks.rst:223
msgid ""
":attr:`~@Task.request` contains information and state related to the "
"executing task."
msgstr ""

#: ../../userguide/tasks.rst:226
msgid "The request defines the following attributes:"
msgstr ""

#: ../../userguide/tasks.rst:228
msgid "The unique id of the executing task."
msgstr ""

#: ../../userguide/tasks.rst:230
msgid "The unique id a group, if this task is a member."
msgstr ""

#: ../../userguide/tasks.rst:232
msgid ""
"The unique id of the chord this task belongs to (if the task is part of the "
"header)."
msgstr ""

#: ../../userguide/tasks.rst:235
msgid "Positional arguments."
msgstr ""

#: ../../userguide/tasks.rst:237
msgid "Keyword arguments."
msgstr ""

#: ../../userguide/tasks.rst:239
msgid ""
"How many times the current task has been retried. An integer starting at "
"`0`."
msgstr ""

#: ../../userguide/tasks.rst:242
msgid ""
"Set to :const:`True` if the task is executed locally in the client, and not "
"by a worker."
msgstr ""

#: ../../userguide/tasks.rst:245
msgid ""
"The original ETA of the task (if any). This is in UTC time (depending on the"
" :setting:`CELERY_ENABLE_UTC` setting)."
msgstr ""

#: ../../userguide/tasks.rst:249
msgid ""
"The original expiry time of the task (if any). This is in UTC time "
"(depending on the :setting:`CELERY_ENABLE_UTC` setting)."
msgstr ""

#: ../../userguide/tasks.rst:253
msgid "The file the worker logs to.  See `Logging`_."
msgstr ""

#: ../../userguide/tasks.rst:255
msgid "The current log level used."
msgstr ""

#: ../../userguide/tasks.rst:257
msgid "Hostname of the worker instance executing the task."
msgstr ""

#: ../../userguide/tasks.rst:259
msgid ""
"Additional message delivery information. This is a mapping containing the "
"exchange and routing key used to deliver this task.  Used by e.g. "
":meth:`~@Task.retry` to resend the task to the same destination queue. "
"Availability of keys in this dict depends on the message broker used."
msgstr ""

#: ../../userguide/tasks.rst:266
msgid "This flag is set to true if the task was not executed by the worker."
msgstr ""

#: ../../userguide/tasks.rst:269
msgid "A list of subtasks to be called if this task returns successfully."
msgstr ""

#: ../../userguide/tasks.rst:271
msgid "A list of subtasks to be called if this task fails."
msgstr ""

#: ../../userguide/tasks.rst:273
msgid "Set to true the caller has utc enabled (:setting:`CELERY_ENABLE_UTC`)."
msgstr ""

#: ../../userguide/tasks.rst:278
msgid "Mapping of message headers (may be :const:`None`)."
msgstr ""

#: ../../userguide/tasks.rst:280
msgid "Where to send reply to (queue name)."
msgstr ""

#: ../../userguide/tasks.rst:282
msgid ""
"Usually the same as the task id, often used in amqp to keep track of what a "
"reply is for."
msgstr ""

#: ../../userguide/tasks.rst:286
msgid "An example task accessing information in the context is:"
msgstr ""

#: ../../userguide/tasks.rst:296
msgid ""
"The ``bind`` argument means that the function will be a \"bound method\" so "
"that you can access attributes and methods on the task type instance."
msgstr ""

#: ../../userguide/tasks.rst:302
msgid "Logging"
msgstr ""

#: ../../userguide/tasks.rst:304
msgid ""
"The worker will automatically set up logging for you, or you can configure "
"logging manually."
msgstr ""

#: ../../userguide/tasks.rst:307
msgid ""
"A special logger is available named \"celery.task\", you can inherit from "
"this logger to automatically get the task name and unique id as part of the "
"logs."
msgstr ""

#: ../../userguide/tasks.rst:311
msgid ""
"The best practice is to create a common logger for all of your tasks at the "
"top of your module:"
msgstr ""

#: ../../userguide/tasks.rst:325
msgid ""
"Celery uses the standard Python logger library, for which documentation can "
"be found in the :mod:`logging` module."
msgstr ""

#: ../../userguide/tasks.rst:329
msgid ""
"You can also use :func:`print`, as anything written to standard out/-err "
"will be redirected to logging system (you can disable this, see "
":setting:`CELERY_REDIRECT_STDOUTS`)."
msgstr ""

#: ../../userguide/tasks.rst:336
msgid "Retrying"
msgstr ""

#: ../../userguide/tasks.rst:338
msgid ""
":meth:`~@Task.retry` can be used to re-execute the task, for example in the "
"event of recoverable errors."
msgstr ""

#: ../../userguide/tasks.rst:341
msgid ""
"When you call ``retry`` it will send a new message, using the same task-id, "
"and it will take care to make sure the message is delivered to the same "
"queue as the originating task."
msgstr ""

#: ../../userguide/tasks.rst:345
msgid ""
"When a task is retried this is also recorded as a task state, so that you "
"can track the progress of the task using the result instance (see :ref"
":`task-states`)."
msgstr ""

#: ../../userguide/tasks.rst:349
msgid "Here's an example using ``retry``:"
msgstr ""

#: ../../userguide/tasks.rst:363
msgid ""
"The :meth:`~@Task.retry` call will raise an exception so any code after the "
"retry will not be reached.  This is the :exc:`~@Retry` exception, it is not "
"handled as an error but rather as a semi-predicate to signify to the worker "
"that the task is to be retried, so that it can store the correct state when "
"a result backend is enabled."
msgstr ""

#: ../../userguide/tasks.rst:369
msgid ""
"This is normal operation and always happens unless the ``throw`` argument to"
" retry is set to :const:`False`."
msgstr ""

#: ../../userguide/tasks.rst:372
msgid ""
"The bind argument to the task decorator will give access to ``self`` (the "
"task type instance)."
msgstr ""

#: ../../userguide/tasks.rst:375
msgid ""
"The ``exc`` method is used to pass exception information that is used in "
"logs, and when storing task results. Both the exception and the traceback "
"will be available in the task state (if a result backend is enabled)."
msgstr ""

#: ../../userguide/tasks.rst:380
msgid ""
"If the task has a ``max_retries`` value the current exception will be re-"
"raised if the max number of retries has been exceeded, but this will not "
"happen if:"
msgstr ""

#: ../../userguide/tasks.rst:384
msgid "An ``exc`` argument was not given."
msgstr ""

#: ../../userguide/tasks.rst:386
msgid "In this case the :exc:`~@MaxRetriesExceeded` exception will be raised."
msgstr ""

#: ../../userguide/tasks.rst:389
msgid "There is no current exception"
msgstr ""

#: ../../userguide/tasks.rst:391
msgid ""
"If there's no original exception to re-raise the ``exc`` argument will be "
"used instead, so:"
msgstr ""

#: ../../userguide/tasks.rst:398
msgid "will raise the ``exc`` argument given."
msgstr ""

#: ../../userguide/tasks.rst:403
msgid "Using a custom retry delay"
msgstr ""

#: ../../userguide/tasks.rst:405
msgid ""
"When a task is to be retried, it can wait for a given amount of time before "
"doing so, and the default delay is defined by the "
":attr:`~@Task.default_retry_delay` attribute. By default this is set to 3 "
"minutes. Note that the unit for setting the delay is in seconds (int or "
"float)."
msgstr ""

#: ../../userguide/tasks.rst:411
msgid ""
"You can also provide the `countdown` argument to :meth:`~@Task.retry` to "
"override this default."
msgstr ""

#: ../../userguide/tasks.rst:427
msgid "List of Options"
msgstr ""

#: ../../userguide/tasks.rst:429
msgid ""
"The task decorator can take a number of options that change the way the task"
" behaves, for example you can set the rate limit for a task using the "
":attr:`rate_limit` option."
msgstr ""

#: ../../userguide/tasks.rst:433
msgid ""
"Any keyword argument passed to the task decorator will actually be set as an"
" attribute of the resulting task class, and this is a list of the built-in "
"attributes."
msgstr ""

#: ../../userguide/tasks.rst:438
msgid "General"
msgstr ""

#: ../../userguide/tasks.rst:444
msgid "The name the task is registered as."
msgstr ""

#: ../../userguide/tasks.rst:446
msgid ""
"You can set this name manually, or a name will be automatically generated "
"using the module and class name.  See :ref:`task-names`."
msgstr ""

#: ../../userguide/tasks.rst:452
msgid ""
"If the task is being executed this will contain information about the "
"current request.  Thread local storage is used."
msgstr ""

#: ../../userguide/tasks.rst:455
msgid "See :ref:`task-request-info`."
msgstr ""

#: ../../userguide/tasks.rst:459 ../../userguide/tasks.rst:1074
msgid ""
"Abstract classes are not registered, but are used as the base class for new "
"task types."
msgstr ""

#: ../../userguide/tasks.rst:464
msgid ""
"The maximum number of attempted retries before giving up. If the number of "
"retries exceeds this value a :exc:`~@MaxRetriesExceeded` exception will be "
"raised.  *NOTE:* You have to call :meth:`~@Task.retry` manually, as it will "
"not automatically retry on exception.."
msgstr ""

#: ../../userguide/tasks.rst:469
msgid ""
"The default value is 3. A value of :const:`None` will disable the retry "
"limit and the task will retry forever until it succeeds."
msgstr ""

#: ../../userguide/tasks.rst:475
msgid ""
"Optional tuple of expected error classes that should not be regarded as an "
"actual error."
msgstr ""

#: ../../userguide/tasks.rst:478
msgid ""
"Errors in this list will be reported as a failure to the result backend, but"
" the worker will not log the event as an error, and no traceback will be "
"included."
msgstr ""

#: ../../userguide/tasks.rst:482
msgid "Example:"
msgstr ""

#: ../../userguide/tasks.rst:490
msgid "Error types:"
msgstr ""

#: ../../userguide/tasks.rst:492
msgid "Expected errors (in ``Task.throws``)"
msgstr ""

#: ../../userguide/tasks.rst:494
msgid "Logged with severity ``INFO``, traceback excluded."
msgstr ""

#: ../../userguide/tasks.rst:496
msgid "Unexpected errors"
msgstr ""

#: ../../userguide/tasks.rst:498
msgid "Logged with severity ``ERROR``, with traceback included."
msgstr ""

#: ../../userguide/tasks.rst:502
msgid ""
"Default time in seconds before a retry of the task should be executed.  Can "
"be either :class:`int` or :class:`float`. Default is a 3 minute delay."
msgstr ""

#: ../../userguide/tasks.rst:508
msgid ""
"Set the rate limit for this task type which limits the number of tasks that "
"can be run in a given time frame.  Tasks will still complete when a rate "
"limit is in effect, but it may take some time before it's allowed to start."
msgstr ""

#: ../../userguide/tasks.rst:513
msgid ""
"If this is :const:`None` no rate limit is in effect. If it is an integer or "
"float, it is interpreted as \"tasks per second\"."
msgstr ""

#: ../../userguide/tasks.rst:516
msgid ""
"The rate limits can be specified in seconds, minutes or hours by appending "
"`\"/s\"`, `\"/m\"` or `\"/h\"` to the value.  Tasks will be evenly "
"distributed over the specified time frame."
msgstr ""

#: ../../userguide/tasks.rst:520
msgid ""
"Example: `\"100/m\"` (hundred tasks a minute). This will enforce a minimum "
"delay of 10ms between starting two tasks."
msgstr ""

#: ../../userguide/tasks.rst:523
msgid ""
"Default is the :setting:`CELERY_DEFAULT_RATE_LIMIT` setting, which if not "
"specified means rate limiting for tasks is disabled by default."
msgstr ""

#: ../../userguide/tasks.rst:528
msgid ""
"The hard time limit, in seconds, for this task.  If not set then the workers"
" default will be used."
msgstr ""

#: ../../userguide/tasks.rst:533
msgid ""
"The soft time limit for this task.  If not set then the workers default will"
" be used."
msgstr ""

#: ../../userguide/tasks.rst:538
msgid ""
"Don't store task state.    Note that this means you can't use "
":class:`~celery.result.AsyncResult` to check if the task is ready, or get "
"its return value."
msgstr ""

#: ../../userguide/tasks.rst:544
msgid ""
"If :const:`True`, errors will be stored even if the task is configured to "
"ignore results."
msgstr ""

#: ../../userguide/tasks.rst:549
msgid ""
"Send an email whenever a task of this type fails. Defaults to the "
":setting:`CELERY_SEND_TASK_ERROR_EMAILS` setting. See :ref:`conf-error-"
"mails` for more information."
msgstr ""

#: ../../userguide/tasks.rst:555
msgid ""
"If the sending of error emails is enabled for this task, then this is the "
"class defining the logic to send error mails."
msgstr ""

#: ../../userguide/tasks.rst:560
msgid ""
"A string identifying the default serialization method to use. Defaults to "
"the :setting:`CELERY_TASK_SERIALIZER` setting.  Can be `pickle` `json`, "
"`yaml`, or any custom serialization methods that have been registered with "
":mod:`kombu.serialization.registry`."
msgstr ""

#: ../../userguide/tasks.rst:566
msgid "Please see :ref:`calling-serializers` for more information."
msgstr ""

#: ../../userguide/tasks.rst:570
msgid "A string identifying the default compression scheme to use."
msgstr ""

#: ../../userguide/tasks.rst:572
msgid ""
"Defaults to the :setting:`CELERY_MESSAGE_COMPRESSION` setting. Can be "
"`gzip`, or `bzip2`, or any custom compression schemes that have been "
"registered with the :mod:`kombu.compression` registry."
msgstr ""

#: ../../userguide/tasks.rst:576
msgid "Please see :ref:`calling-compression` for more information."
msgstr ""

#: ../../userguide/tasks.rst:580
msgid ""
"The result store backend to use for this task.  Defaults to the "
":setting:`CELERY_RESULT_BACKEND` setting."
msgstr ""

#: ../../userguide/tasks.rst:585
msgid ""
"If set to :const:`True` messages for this task will be acknowledged "
"**after** the task has been executed, not *just before*, which is the "
"default behavior."
msgstr ""

#: ../../userguide/tasks.rst:589
msgid ""
"Note that this means the task may be executed twice if the worker crashes in"
" the middle of execution, which may be acceptable for some applications."
msgstr ""

#: ../../userguide/tasks.rst:593
msgid ""
"The global default can be overridden by the :setting:`CELERY_ACKS_LATE` "
"setting."
msgstr ""

#: ../../userguide/tasks.rst:600
msgid ""
"If :const:`True` the task will report its status as \"started\" when the "
"task is executed by a worker. The default value is :const:`False` as the "
"normal behaviour is to not report that level of granularity. Tasks are "
"either pending, finished, or waiting to be retried.  Having a \"started\" "
"status can be useful for when there are long running tasks and there is a "
"need to report which task is currently running."
msgstr ""

#: ../../userguide/tasks.rst:608
msgid ""
"The host name and process id of the worker executing the task will be "
"available in the state metadata (e.g. `result.info['pid']`)"
msgstr ""

#: ../../userguide/tasks.rst:611
msgid ""
"The global default can be overridden by the :setting:`CELERY_TRACK_STARTED` "
"setting."
msgstr ""

#: ../../userguide/tasks.rst:617
msgid "The API reference for :class:`~@Task`."
msgstr ""

#: ../../userguide/tasks.rst:622
msgid "States"
msgstr ""

#: ../../userguide/tasks.rst:624
msgid ""
"Celery can keep track of the tasks current state.  The state also contains "
"the result of a successful task, or the exception and traceback information "
"of a failed task."
msgstr ""

#: ../../userguide/tasks.rst:628
msgid ""
"There are several *result backends* to choose from, and they all have "
"different strengths and weaknesses (see :ref:`task-result-backends`)."
msgstr ""

#: ../../userguide/tasks.rst:631
msgid ""
"During its lifetime a task will transition through several possible states, "
"and each state may have arbitrary metadata attached to it.  When a task "
"moves into a new state the previous state is forgotten about, but some "
"transitions can be deducted, (e.g. a task now in the :state:`FAILED` state, "
"is implied to have been in the :state:`STARTED` state at some point)."
msgstr ""

#: ../../userguide/tasks.rst:638
msgid ""
"There are also sets of states, like the set of :state:`FAILURE_STATES`, and "
"the set of :state:`READY_STATES`."
msgstr ""

#: ../../userguide/tasks.rst:641
msgid ""
"The client uses the membership of these sets to decide whether the exception"
" should be re-raised (:state:`PROPAGATE_STATES`), or whether the state can "
"be cached (it can if the task is ready)."
msgstr ""

#: ../../userguide/tasks.rst:645
msgid "You can also define :ref:`custom-states`."
msgstr ""

#: ../../userguide/tasks.rst:650
msgid "Result Backends"
msgstr ""

#: ../../userguide/tasks.rst:652
msgid ""
"If you want to keep track of tasks or need the return values, then Celery "
"must store or send the states somewhere so that they can be retrieved later."
" There are several built-in result backends to choose from: "
"SQLAlchemy/Django ORM, Memcached, RabbitMQ (amqp), MongoDB, and Redis -- or "
"you can define your own."
msgstr ""

#: ../../userguide/tasks.rst:657
msgid ""
"No backend works well for every use case. You should read about the "
"strengths and weaknesses of each backend, and choose the most appropriate "
"for your needs."
msgstr ""

#: ../../userguide/tasks.rst:664
msgid ":ref:`conf-result-backend`"
msgstr ""

#: ../../userguide/tasks.rst:667
msgid "RabbitMQ Result Backend"
msgstr ""

#: ../../userguide/tasks.rst:669
msgid ""
"The RabbitMQ result backend (amqp) is special as it does not actually "
"*store* the states, but rather sends them as messages.  This is an important"
" difference as it means that a result *can only be retrieved once*; If you "
"have two processes waiting for the same result, one of the processes will "
"never receive the result!"
msgstr ""

#: ../../userguide/tasks.rst:675
msgid ""
"Even with that limitation, it is an excellent choice if you need to receive "
"state changes in real-time.  Using messaging means the client does not have "
"to poll for new states."
msgstr ""

#: ../../userguide/tasks.rst:679
msgid ""
"There are several other pitfalls you should be aware of when using the "
"RabbitMQ result backend:"
msgstr ""

#: ../../userguide/tasks.rst:682
msgid ""
"Every new task creates a new queue on the server, with thousands of tasks "
"the broker may be overloaded with queues and this will affect performance in"
" negative ways. If you're using RabbitMQ then each queue will be a separate "
"Erlang process, so if you're planning to keep many results simultaneously "
"you may have to increase the Erlang process limit, and the maximum number of"
" file descriptors your OS allows."
msgstr ""

#: ../../userguide/tasks.rst:689
msgid ""
"Old results will be cleaned automatically, based on the "
":setting:`CELERY_TASK_RESULT_EXPIRES` setting.  By default this is set to "
"expire after 1 day: if you have a very busy cluster you should lower this "
"value."
msgstr ""

#: ../../userguide/tasks.rst:694
msgid ""
"For a list of options supported by the RabbitMQ result backend, please see "
":ref:`conf-amqp-result-backend`."
msgstr ""

#: ../../userguide/tasks.rst:699
msgid "Database Result Backend"
msgstr ""

#: ../../userguide/tasks.rst:701
msgid ""
"Keeping state in the database can be convenient for many, especially for web"
" applications with a database already in place, but it also comes with "
"limitations."
msgstr ""

#: ../../userguide/tasks.rst:705
msgid ""
"Polling the database for new states is expensive, and so you should increase"
" the polling intervals of operations such as `result.get()`."
msgstr ""

#: ../../userguide/tasks.rst:708
msgid ""
"Some databases use a default transaction isolation level that is not "
"suitable for polling tables for changes."
msgstr ""

#: ../../userguide/tasks.rst:711
msgid ""
"In MySQL the default transaction isolation level is `REPEATABLE-READ`, which"
" means the transaction will not see changes by other transactions until the "
"transaction is committed.  It is recommended that you change to the `READ-"
"COMMITTED` isolation level."
msgstr ""

#: ../../userguide/tasks.rst:720
msgid "Built-in States"
msgstr ""

#: ../../userguide/tasks.rst:725
msgid "PENDING"
msgstr ""

#: ../../userguide/tasks.rst:727
msgid ""
"Task is waiting for execution or unknown. Any task id that is not known is "
"implied to be in the pending state."
msgstr ""

#: ../../userguide/tasks.rst:733
msgid "STARTED"
msgstr ""

#: ../../userguide/tasks.rst:735
msgid ""
"Task has been started. Not reported by default, to enable please see "
":attr:`@Task.track_started`."
msgstr ""

#: ../../userguide/tasks.rst:738
msgid "`pid` and `hostname` of the worker process executing the task."
msgstr ""

#: ../../userguide/tasks.rst:744
msgid "SUCCESS"
msgstr ""

#: ../../userguide/tasks.rst:746
msgid "Task has been successfully executed."
msgstr ""

#: ../../userguide/tasks.rst:748
msgid "`result` contains the return value of the task."
msgstr ""

#: ../../userguide/tasks.rst:749 ../../userguide/tasks.rst:750
#: ../../userguide/tasks.rst:762 ../../userguide/tasks.rst:783
msgid "Yes"
msgstr ""

#: ../../userguide/tasks.rst:755
msgid "FAILURE"
msgstr ""

#: ../../userguide/tasks.rst:757
msgid "Task execution resulted in failure."
msgstr ""

#: ../../userguide/tasks.rst:759
msgid ""
"`result` contains the exception occurred, and `traceback` contains the "
"backtrace of the stack at the point when the exception was raised."
msgstr ""

#: ../../userguide/tasks.rst:767
msgid "RETRY"
msgstr ""

#: ../../userguide/tasks.rst:769
msgid "Task is being retried."
msgstr ""

#: ../../userguide/tasks.rst:771
msgid ""
"`result` contains the exception that caused the retry, and `traceback` "
"contains the backtrace of the stack at the point when the exceptions was "
"raised."
msgstr ""

#: ../../userguide/tasks.rst:774
msgid "No"
msgstr ""

#: ../../userguide/tasks.rst:779
msgid "REVOKED"
msgstr ""

#: ../../userguide/tasks.rst:781
msgid "Task has been revoked."
msgstr ""

#: ../../userguide/tasks.rst:788
msgid "Custom states"
msgstr ""

#: ../../userguide/tasks.rst:790
msgid ""
"You can easily define your own states, all you need is a unique name. The "
"name of the state is usually an uppercase string.  As an example you could "
"have a look at :mod:`abortable tasks <~celery.contrib.abortable>` which "
"defines its own custom :state:`ABORTED` state."
msgstr ""

#: ../../userguide/tasks.rst:795
msgid "Use :meth:`~@Task.update_state` to update a task's state::"
msgstr ""

#: ../../userguide/tasks.rst:804
msgid ""
"Here I created the state `\"PROGRESS\"`, which tells any application aware "
"of this state that the task is currently in progress, and also where it is "
"in the process by having `current` and `total` counts as part of the state "
"metadata.  This can then be used to create e.g. progress bars."
msgstr ""

#: ../../userguide/tasks.rst:812
msgid "Creating pickleable exceptions"
msgstr ""

#: ../../userguide/tasks.rst:814
msgid ""
"A rarely known Python fact is that exceptions must conform to some simple "
"rules to support being serialized by the pickle module."
msgstr ""

#: ../../userguide/tasks.rst:817
msgid ""
"Tasks that raise exceptions that are not pickleable will not work properly "
"when Pickle is used as the serializer."
msgstr ""

#: ../../userguide/tasks.rst:820
msgid ""
"To make sure that your exceptions are pickleable the exception *MUST* "
"provide the original arguments it was instantiated with in its ``.args`` "
"attribute.  The simplest way to ensure this is to have the exception call "
"``Exception.__init__``."
msgstr ""

#: ../../userguide/tasks.rst:825
msgid "Let's look at some examples that work, and one that doesn't:"
msgstr ""

#: ../../userguide/tasks.rst:848
msgid ""
"So the rule is: For any exception that supports custom arguments ``*args``, "
"``Exception.__init__(self, *args)`` must be used."
msgstr ""

#: ../../userguide/tasks.rst:852
msgid ""
"There is no special support for *keyword arguments*, so if you want to "
"preserve keyword arguments when the exception is unpickled you have to pass "
"them as regular args:"
msgstr ""

#: ../../userguide/tasks.rst:870
msgid "Semipredicates"
msgstr ""

#: ../../userguide/tasks.rst:872
msgid ""
"The worker wraps the task in a tracing function which records the final "
"state of the task.  There are a number of exceptions that can be used to "
"signal this function to change how it treats the return of the task."
msgstr ""

#: ../../userguide/tasks.rst:879
msgid "Ignore"
msgstr ""

#: ../../userguide/tasks.rst:881
msgid ""
"The task may raise :exc:`~@Ignore` to force the worker to ignore the task.  "
"This means that no state will be recorded for the task, but the message is "
"still acknowledged (removed from queue)."
msgstr ""

#: ../../userguide/tasks.rst:885
msgid ""
"This can be used if you want to implement custom revoke-like functionality, "
"or manually store the result of a task."
msgstr ""

#: ../../userguide/tasks.rst:888
msgid "Example keeping revoked tasks in a Redis set:"
msgstr ""

#: ../../userguide/tasks.rst:899
msgid "Example that stores results manually:"
msgstr ""

#: ../../userguide/tasks.rst:915
msgid "Reject"
msgstr ""

#: ../../userguide/tasks.rst:917
msgid ""
"The task may raise :exc:`~@Reject` to reject the task message using AMQPs "
"``basic_reject`` method.  This will not have any effect unless "
":attr:`Task.acks_late` is enabled."
msgstr ""

#: ../../userguide/tasks.rst:921
msgid ""
"Rejecting a message has the same effect as acking it, but some brokers may "
"implement additional functionality that can be used. For example RabbitMQ "
"supports the concept of `Dead Letter Exchanges`_ where a queue can be "
"configured to use a dead letter exchange that rejected messages are "
"redelivered to."
msgstr ""

#: ../../userguide/tasks.rst:929
msgid ""
"Reject can also be used to requeue messages, but please be very careful when"
" using this as it can easily result in an infinite message loop."
msgstr ""

#: ../../userguide/tasks.rst:932
msgid "Example using reject when a task causes an out of memory condition:"
msgstr ""

#: ../../userguide/tasks.rst:958
msgid "Example requeuing the message:"
msgstr ""

#: ../../userguide/tasks.rst:970
msgid ""
"Consult your broker documentation for more details about the "
"``basic_reject`` method."
msgstr ""

#: ../../userguide/tasks.rst:977
msgid "Retry"
msgstr ""

#: ../../userguide/tasks.rst:979
msgid ""
"The :exc:`~@Retry` exception is raised by the ``Task.retry`` method to tell "
"the worker that the task is being retried."
msgstr ""

#: ../../userguide/tasks.rst:985
msgid "Custom task classes"
msgstr ""

#: ../../userguide/tasks.rst:987
msgid ""
"All tasks inherit from the :class:`@Task` class. The :meth:`~@Task.run` "
"method becomes the task body."
msgstr ""

#: ../../userguide/tasks.rst:990
msgid "As an example, the following code,"
msgstr ""

#: ../../userguide/tasks.rst:999
msgid "will do roughly this behind the scenes:"
msgstr ""

#: ../../userguide/tasks.rst:1011
msgid "Instantiation"
msgstr ""

#: ../../userguide/tasks.rst:1013
msgid ""
"A task is **not** instantiated for every request, but is registered in the "
"task registry as a global instance."
msgstr ""

#: ../../userguide/tasks.rst:1016
msgid ""
"This means that the ``__init__`` constructor will only be called once per "
"process, and that the task class is semantically closer to an Actor."
msgstr ""

#: ../../userguide/tasks.rst:1020
msgid "If you have a task,"
msgstr ""

#: ../../userguide/tasks.rst:1037
msgid ""
"And you route every request to the same process, then it will keep state "
"between requests."
msgstr ""

#: ../../userguide/tasks.rst:1040
msgid ""
"This can also be useful to cache resources, e.g. a base Task class that "
"caches a database connection:"
msgstr ""

#: ../../userguide/tasks.rst:1058
msgid "that can be added to tasks like this:"
msgstr ""

#: ../../userguide/tasks.rst:1068
msgid ""
"The ``db`` attribute of the ``process_rows`` task will then always stay the "
"same in each process."
msgstr ""

#: ../../userguide/tasks.rst:1072
msgid "Abstract classes"
msgstr ""

#: ../../userguide/tasks.rst:1094
msgid "Handlers"
msgstr ""

#: ../../userguide/tasks.rst:1098
msgid "Handler called after the task returns."
msgstr ""

#: ../../userguide/tasks.rst:1100
msgid "Current task state."
msgstr ""

#: ../../userguide/tasks.rst:1101
msgid "Task return value/exception."
msgstr ""

#: ../../userguide/tasks.rst:1102
msgid "Unique id of the task."
msgstr ""

#: ../../userguide/tasks.rst:1103
msgid "Original arguments for the task that returned."
msgstr ""

#: ../../userguide/tasks.rst:1104
msgid "Original keyword arguments for the task that returned."
msgstr ""

#: ../../userguide/tasks.rst:1107
msgid ""
":class:`~celery.datastructures.ExceptionInfo` instance, containing the "
"traceback (if any)."
msgstr ""

#: ../../userguide/tasks.rst:1110 ../../userguide/tasks.rst:1125
#: ../../userguide/tasks.rst:1139 ../../userguide/tasks.rst:1150
msgid "The return value of this handler is ignored."
msgstr ""

#: ../../userguide/tasks.rst:1114
msgid "This is run by the worker when the task fails."
msgstr ""

#: ../../userguide/tasks.rst:1116
msgid "The exception raised by the task."
msgstr ""

#: ../../userguide/tasks.rst:1117
msgid "Unique id of the failed task."
msgstr ""

#: ../../userguide/tasks.rst:1118
msgid "Original arguments for the task that failed."
msgstr ""

#: ../../userguide/tasks.rst:1119
msgid "Original keyword arguments for the task that failed."
msgstr ""

#: ../../userguide/tasks.rst:1122 ../../userguide/tasks.rst:1136
msgid ""
":class:`~celery.datastructures.ExceptionInfo` instance, containing the "
"traceback."
msgstr ""

#: ../../userguide/tasks.rst:1129
msgid "This is run by the worker when the task is to be retried."
msgstr ""

#: ../../userguide/tasks.rst:1131
msgid "The exception sent to :meth:`~@Task.retry`."
msgstr ""

#: ../../userguide/tasks.rst:1132
msgid "Unique id of the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1133
msgid "Original arguments for the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1134
msgid "Original keyword arguments for the retried task."
msgstr ""

#: ../../userguide/tasks.rst:1143
msgid "Run by the worker if the task executes successfully."
msgstr ""

#: ../../userguide/tasks.rst:1145
msgid "The return value of the task."
msgstr ""

#: ../../userguide/tasks.rst:1146
msgid "Unique id of the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1147
msgid "Original arguments for the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1148
msgid "Original keyword arguments for the executed task."
msgstr ""

#: ../../userguide/tasks.rst:1153
msgid "on_retry"
msgstr ""

#: ../../userguide/tasks.rst:1158
msgid "How it works"
msgstr ""

#: ../../userguide/tasks.rst:1160
msgid ""
"Here comes the technical details, this part isn't something you need to "
"know, but you may be interested."
msgstr ""

#: ../../userguide/tasks.rst:1163
msgid ""
"All defined tasks are listed in a registry.  The registry contains a list of"
" task names and their task classes.  You can investigate this registry "
"yourself:"
msgstr ""

#: ../../userguide/tasks.rst:1178
msgid ""
"This is the list of tasks built-in to celery.  Note that tasks will only be "
"registered when the module they are defined in is imported."
msgstr ""

#: ../../userguide/tasks.rst:1181
msgid ""
"The default loader imports any modules listed in the "
":setting:`CELERY_IMPORTS` setting."
msgstr ""

#: ../../userguide/tasks.rst:1184
msgid ""
"The entity responsible for registering your task in the registry is the "
"metaclass: :class:`~celery.task.base.TaskType`."
msgstr ""

#: ../../userguide/tasks.rst:1187
msgid ""
"If you want to register your task manually you can mark the task as "
":attr:`~@Task.abstract`:"
msgstr ""

#: ../../userguide/tasks.rst:1195
msgid ""
"This way the task won't be registered, but any task inheriting from it will "
"be."
msgstr ""

#: ../../userguide/tasks.rst:1198
msgid ""
"When tasks are sent, no actual function code is sent with it, just the name "
"of the task to execute.  When the worker then receives the message it can "
"look up the name in its task registry to find the execution code."
msgstr ""

#: ../../userguide/tasks.rst:1202
msgid ""
"This means that your workers should always be updated with the same software"
" as the client.  This is a drawback, but the alternative is a technical "
"challenge that has yet to be solved."
msgstr ""

#: ../../userguide/tasks.rst:1209
msgid "Tips and Best Practices"
msgstr ""

#: ../../userguide/tasks.rst:1214
msgid "Ignore results you don't want"
msgstr ""

#: ../../userguide/tasks.rst:1216
msgid ""
"If you don't care about the results of a task, be sure to set the "
":attr:`~@Task.ignore_result` option, as storing results wastes time and "
"resources."
msgstr ""

#: ../../userguide/tasks.rst:1226
msgid ""
"Results can even be disabled globally using the "
":setting:`CELERY_IGNORE_RESULT` setting."
msgstr ""

#: ../../userguide/tasks.rst:1232
msgid "Disable rate limits if they're not used"
msgstr ""

#: ../../userguide/tasks.rst:1234
msgid ""
"Disabling rate limits altogether is recommended if you don't have any tasks "
"using them.  This is because the rate limit subsystem introduces quite a lot"
" of complexity."
msgstr ""

#: ../../userguide/tasks.rst:1238
msgid ""
"Set the :setting:`CELERY_DISABLE_RATE_LIMITS` setting to globally disable "
"rate limits:"
msgstr ""

#: ../../userguide/tasks.rst:1245
msgid ""
"You find additional optimization tips in the :ref:`Optimizing Guide <guide-"
"optimizing>`."
msgstr ""

#: ../../userguide/tasks.rst:1251
msgid "Avoid launching synchronous subtasks"
msgstr ""

#: ../../userguide/tasks.rst:1253
msgid ""
"Having a task wait for the result of another task is really inefficient, and"
" may even cause a deadlock if the worker pool is exhausted."
msgstr ""

#: ../../userguide/tasks.rst:1256
msgid ""
"Make your design asynchronous instead, for example by using *callbacks*."
msgstr ""

#: ../../userguide/tasks.rst:1258
msgid "**Bad**:"
msgstr ""

#: ../../userguide/tasks.rst:1281
msgid "**Good**:"
msgstr ""

#: ../../userguide/tasks.rst:1303
msgid ""
"Here I instead created a chain of tasks by linking together different "
":func:`~celery.subtask`'s. You can read about chains and other powerful "
"constructs at :ref:`designing-workflows`."
msgstr ""

#: ../../userguide/tasks.rst:1311
msgid "Performance and Strategies"
msgstr ""

#: ../../userguide/tasks.rst:1316
msgid "Granularity"
msgstr ""

#: ../../userguide/tasks.rst:1318
msgid ""
"The task granularity is the amount of computation needed by each subtask. In"
" general it is better to split the problem up into many small tasks, than "
"have a few long running tasks."
msgstr ""

#: ../../userguide/tasks.rst:1322
msgid ""
"With smaller tasks you can process more tasks in parallel and the tasks "
"won't run long enough to block the worker from processing other waiting "
"tasks."
msgstr ""

#: ../../userguide/tasks.rst:1325
msgid ""
"However, executing a task does have overhead. A message needs to be sent, "
"data may not be local, etc. So if the tasks are too fine-grained the "
"additional overhead may not be worth it in the end."
msgstr ""

#: ../../userguide/tasks.rst:1331
msgid ""
"The book `Art of Concurrency`_ has a section dedicated to the topic of task "
"granularity [AOC1]_."
msgstr ""

#: ../../userguide/tasks.rst:1336
msgid ""
"Breshears, Clay. Section 2.2.1, \"The Art of Concurrency\". O'Reilly Media, "
"Inc. May 15, 2009.  ISBN-13 978-0-596-52153-0."
msgstr ""

#: ../../userguide/tasks.rst:1342
msgid "Data locality"
msgstr ""

#: ../../userguide/tasks.rst:1344
msgid ""
"The worker processing the task should be as close to the data as possible.  "
"The best would be to have a copy in memory, the worst would be a full "
"transfer from another continent."
msgstr ""

#: ../../userguide/tasks.rst:1348
msgid ""
"If the data is far away, you could try to run another worker at location, or"
" if that's not possible - cache often used data, or preload data you know is"
" going to be used."
msgstr ""

#: ../../userguide/tasks.rst:1352
msgid ""
"The easiest way to share data between workers is to use a distributed cache "
"system, like `memcached`_."
msgstr ""

#: ../../userguide/tasks.rst:1357
msgid ""
"The paper `Distributed Computing Economics`_ by Jim Gray is an excellent "
"introduction to the topic of data locality."
msgstr ""

#: ../../userguide/tasks.rst:1368
msgid "State"
msgstr ""

#: ../../userguide/tasks.rst:1370
msgid ""
"Since celery is a distributed system, you can't know in which process, or on"
" what machine the task will be executed.  You can't even know if the task "
"will run in a timely manner."
msgstr ""

#: ../../userguide/tasks.rst:1374
msgid ""
"The ancient async sayings tells us that “asserting the world is the "
"responsibility of the task”.  What this means is that the world view may "
"have changed since the task was requested, so the task is responsible for "
"making sure the world is how it should be;  If you have a task that re-"
"indexes a search engine, and the search engine should only be re-indexed at "
"maximum every 5 minutes, then it must be the tasks responsibility to assert "
"that, not the callers."
msgstr ""

#: ../../userguide/tasks.rst:1382
msgid ""
"Another gotcha is Django model objects.  They shouldn't be passed on as "
"arguments to tasks.  It's almost always better to re-fetch the object from "
"the database when the task is running instead,  as using old data may lead "
"to race conditions."
msgstr ""

#: ../../userguide/tasks.rst:1387
msgid ""
"Imagine the following scenario where you have an article and a task that "
"automatically expands some abbreviations in it:"
msgstr ""

#: ../../userguide/tasks.rst:1401
msgid ""
"First, an author creates an article and saves it, then the author clicks on "
"a button that initiates the abbreviation task::"
msgstr ""

#: ../../userguide/tasks.rst:1407
msgid ""
"Now, the queue is very busy, so the task won't be run for another 2 minutes."
" In the meantime another author makes changes to the article, so when the "
"task is finally run, the body of the article is reverted to the old version "
"because the task had the old body in its argument."
msgstr ""

#: ../../userguide/tasks.rst:1412
msgid ""
"Fixing the race condition is easy, just use the article id instead, and re-"
"fetch the article in the task body:"
msgstr ""

#: ../../userguide/tasks.rst:1425
msgid ""
"There might even be performance benefits to this approach, as sending large "
"messages may be expensive."
msgstr ""

#: ../../userguide/tasks.rst:1431
msgid "Database transactions"
msgstr ""

#: ../../userguide/tasks.rst:1433
msgid "Let's have a look at another example:"
msgstr ""

#: ../../userguide/tasks.rst:1444
msgid ""
"This is a Django view creating an article object in the database, then "
"passing the primary key to a task.  It uses the `commit_on_success` "
"decorator, which will commit the transaction when the view returns, or roll "
"back if the view raises an exception."
msgstr ""

#: ../../userguide/tasks.rst:1449
msgid ""
"There is a race condition if the task starts executing before the "
"transaction has been committed; The database object does not exist yet!"
msgstr ""

#: ../../userguide/tasks.rst:1453
msgid ""
"The solution is to *always commit transactions before sending tasks "
"depending on state from the current transaction*:"
msgstr ""

#: ../../userguide/tasks.rst:1472
msgid "Example"
msgstr ""

#: ../../userguide/tasks.rst:1474
msgid ""
"Let's take a real wold example; A blog where comments posted needs to be "
"filtered for spam.  When the comment is created, the spam filter runs in the"
" background, so the user doesn't have to wait for it to finish."
msgstr ""

#: ../../userguide/tasks.rst:1478
msgid ""
"I have a Django blog application allowing comments on blog posts.  I'll "
"describe parts of the models/views and tasks for this application."
msgstr ""

#: ../../userguide/tasks.rst:1483
msgid "blog/models.py"
msgstr ""

#: ../../userguide/tasks.rst:1485
msgid "The comment model looks like this:"
msgstr ""

#: ../../userguide/tasks.rst:1509
msgid ""
"In the view where the comment is posted, I first write the comment to the "
"database, then I launch the spam filter task in the background."
msgstr ""

#: ../../userguide/tasks.rst:1515
msgid "blog/views.py"
msgstr ""

#: ../../userguide/tasks.rst:1553
msgid ""
"To filter spam in comments I use `Akismet`_, the service used to filter spam"
" in comments posted to the free weblog platform `Wordpress`.  `Akismet`_ is "
"free for personal use, but for commercial use you need to pay.  You have to "
"sign up to their service to get an API key."
msgstr ""

#: ../../userguide/tasks.rst:1558
msgid ""
"To make API calls to `Akismet`_ I use the `akismet.py`_ library written by "
"`Michael Foord`_."
msgstr ""

#: ../../userguide/tasks.rst:1564
msgid "blog/tasks.py"
msgstr ""
